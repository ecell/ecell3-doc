<?xml version="1.0" encoding="US-ASCII"?>

<!-- ============= Automating Simulation Sessions with ESS ========== -->
<chapter id="writing-ecs"> 
  <title>Scripting Simulation Sessions</title> 

  <highlights>
    <para>By reading this chapter, you can get information about the
    following items:
      <simplelist>
	<member>What is &ecell Session Script (<acronym>ESS</acronym>).</member>

	<member>How to run <acronym>ESS</acronym> in scripting mode.</member>

	<member>How to use <acronym>ESS</acronym> in GUI mode.</member>

	<member>How to automate a simulation run by writing an
          <acronym>ESS</acronym> file.</member>

        <member>How to write frontend software components for &ecell in <productname>Python</productname>.</member>

      </simplelist>
</para>
  </highlights>

  <sect1>
    <title>What is &ecell Session Script?</title>

    <para>An &ecell Session Script (ESS) is a
<productname>Python</productname> script which is loaded by a 
&ecell <classname>Session</classname> object.  A
<classname>Session</classname> instance represents a single run of a
simulation.</para>

    <para>An ESS is used to automate a single run of a simulation session.
  A simple simulation run typically involves the following five stages:
<orderedlist>
	<listitem>
	  <para>Loading a model file.</para>
	  <para>Usually an <acronym>EML</acronym> file is loaded.</para>
	</listitem>
	<listitem>
	  <para>Pre-simulation setup of the simulator.</para> <para>
	  Simulator and model parameters, such as initial
	  values of <classname>Variable</classname> objects and
	  property values of <classname>Process</classname> objects,
	  are set and/or altered.  Also, data
	  <classname>Loggers</classname> may be created in this phase.</para>
	</listitem>
	<listitem>
	  <para>Running simulation.</para>
	  <para>The simulation is run for a certain length of time.</para>
	</listitem>
	<listitem>
	  <para>Post-simulation data processing.</para>
	  <para>In this phase, the resulting state of the model after
	  the simulation and the data logged by the
	  <classname>Logger</classname> objects are examined.  The
	  simulation result may be numerically processed. If
	  necessary, go back to the previous step and run the
	  simulation for more seconds.</para>
	</listitem>
	<listitem>
	  <para>Data saving.</para>
	  <para>Finally, the processed and raw
	  simulation result data are saved to files.</para>
	</listitem>
      </orderedlist>
</para>

    <para>An ESS file usually has an extension '<filename>.py</filename>'.</para>

  </sect1>


  <sect1>
    <title>Running &ecell Session Script</title>

    <para>There are three ways to execute <acronym>ESS</acronym>;

      <itemizedlist>
	<listitem>
	  <para>Execute the script from the operating system's command
	  line (the shell prompt).
          </para>
	</listitem>
	<listitem>
	  <para>Load the script from frontend software such as
	  <productname>Osogo Session Monitor</productname>.</para>
	</listitem>
	<listitem>
	  <para>Use <classname>SessionManager</classname> to automate
	  the invokation of the simulation sessions itself.  This is
	  usually used to write mathematical analysis scripts, such as
	  parameter tuning, which involves multiple runs of the
	  simulator.</para>
	</listitem>

      </itemizedlist>
    </para>

    <sect2>
      <title>Running <acronym>ESS</acronym> in command line mode</title>

      <para>An <acronym>ESS</acronym> can be run by using
      <command>ecell3-session</command> command either in
      <emphasis>batch mode</emphasis> or in <emphasis>interactive
      mode</emphasis>.
      </para>
      
      <sect3>
	<title>Batch mode</title>

	<para>
	To execute an <acronym>ESS</acronym> file without user
	interaction, type the following command at the shell prompt:

        <screen>
          <prompt>$</prompt> <userinput><command>ecell3-session</command> <optional>-f model.eml</optional> <optional>-e</optional> <replaceable>ess.py</replaceable>
          </userinput>
        </screen>

        <command>ecell3-session</command> command creates a simulation
<classname>Session</classname> object and executes the
<acronym>ESS</acronym> file <filename>ess.py</filename> on it.  The
option <optional>-e</optional> can be omitted.  Optionally, if
<optional>-f model.eml</optional> is given, the <acronym>EML</acronym>
file <filename>model.eml</filename> is loaded immediately before
executing the <acronym>ESS</acronym>.
      </para>

      </sect3>

      <sect3>
	<title>Interactive mode</title>

	<para>To run the <command>ecell3-session</command> in
	interactive mode, invoke the command without an
	<acronym>ESS</acronym> file.

        <screen><prompt>$</prompt> <userinput><command>ecell3-session</command> <optional>-f model.eml</optional></userinput>
ecell3-session [ for E-Cell SE Version 3, on Python Version 2.2.1 ]
Copyright (C) 1996-2002 Keio University.
Written by Kouichi Takahashi <email>shafi@e-cell.org</email>
<prompt>ecell3-session>>> </prompt>
        </screen>
        
        The banner and the prompt shown here may vary according to the
        version you are using.  If the option <optional>-f model.eml</optional>
is given, the <acronym>EML</acronym> file <filename>model.eml</filename> is loaded immediately before prompting.
</para>
      </sect3>

      <sect3>
	<title>Giving parameters to the script</title>

	<para>Optionally <emphasis>session parameters</emphasis> can
	be given to the script. Given session parameters can be
	accessible from the <acronym>ESS</acronym> script as global
	variables (see the following section).</para>

	<para>To give the <acronym>ESS</acronym> parameters from the
	<command>ecell3-session</command> command, use either
	<option>-D</option> or <option>--parameters=</option>
	option.
        <screen>
          <prompt>$</prompt> <userinput><command>ecell3-session</command> <option>-D</option><replaceable>NAME1</replaceable>=<replaceable>VALUE1</replaceable> <option>-D</option><replaceable>NAME2</replaceable>=<replaceable>VALUE2</replaceable>...</userinput>
          <prompt>$</prompt> <userinput><command>ecell3-session</command> <option>--parameters="</option>{'<replaceable>NAME1</replaceable>':<replaceable>VALUE1</replaceable>,'<replaceable>NAME2</replaceable>':<replaceable>VALUE2</replaceable>,...}"</userinput>
        </screen>
Both ways, <option>-D</option> and <option>--parameters</option>, can be mixed.
</para>
	<para></para>
      </sect3>


    </sect2>

    <sect2>
      <title>Loading <acronym>ESS</acronym> from Osogo Session Monitor</title>

      <para>To manually load an <acronym>ESS</acronym> file from the GUI, use
      <guimenu>File</guimenu>-><guimenuitem>loadScript</guimenuitem>
      menu button.</para>

      <para><command>gecell</command> command accepts
      <option>-e</option> and <option>-f</option> options in the same way as the
      <command>ecell3-session</command> command.</para>

    </sect2>


    <sect2>
      <title>Using SessionManager</title>

      <para>(a separate chapter?)</para>

    </sect2>

  </sect1>

  <sect1>
    <title>Writing &ecell Session Script</title>

    <para>The syntax of <acronym>ESS</acronym> is a full set of
    <productname>Python</productname> language with some convenient
    features.</para>

    <sect2>
      <title>Using Session methods</title>

      <sect3>
	<title>General rules</title>

      <para>In <acronym>ESS</acronym>, an instance of
    <classname>Session</classname> is given, and any methods defined
    in the class can be used as if it is defined in the global namespace.
    </para>

	<para>For example, to run the simulation for 10 seconds, use
    <methodname>run</methodname> method of the
    <classname>Session</classname> object.
    <informalexample> 
	  <programlisting>self.run( 10 )</programlisting>
	</informalexample> 
    where <methodname>self.</methodname> points to the current
    <classname>Session</classname> object given by the
    system. Alternatively, you can use <varname>theSession</varname> 
    in place of the <varname>self</varname>.
    <informalexample> 
	  <programlisting>theSession.run( 10 )</programlisting>
	</informalexample> 
    </para>

    <para>Unlike usual <productname>Python</productname> script, you
    can omit the object on which the method is called if the method is for
    the current <classname>Session</classname>.
    <informalexample>
	<programlisting>run( 10 )</programlisting>
    </informalexample>
    </para>

      </sect3>


      <sect3>
	<title>Loading a model</title>

      <para>Let's try this in the interactive mode of the
      <command>ecell3-session</command> command.  On the prompt of the
      command, load an <acronym>EML</acronym> file by using
      <methodname>loadModel</methodname>() method.

      <informalexample>
	  <screen><prompt>ecell3-session>>> </prompt><userinput>loadModel( 'simple.eml' )</userinput></screen>
	</informalexample>
    
    Then the prompt changes from <prompt>ecell3-session>>> </prompt>
    to <prompt><replaceable>model_name</replaceable>,
    t=<replaceable>current time</replaceable>>>> </prompt>
    <informalexample><screen><prompt>simple.eml, t=0>>> </prompt></screen>
	</informalexample>
    </para>
      </sect3>

      <sect3>
	<title>Running the simulation</title>

	<para>To proceed the time by executing the simulation,
	<methodname>step</methodname>() and
	<methodname>run</methodname>() methods are used.</para>

	<informalexample><screen><prompt>simple.eml, t=0>>> </prompt><userinput>step()</userinput>
<prompt>simple.eml, t=0>>> </prompt><userinput>step()</userinput>
<prompt>simple.eml, t=7.67306e-07>>> </prompt><userinput>run( 10 )</userinput>
<prompt>simple.eml, t=10.0032>>> </prompt>
</screen>
	</informalexample>

	<para>
          <methodname>step</methodname>( <parameter>n</parameter> )
 conducts <parameter>n</parameter> steps of the simulation. The
 default value of <parameter>n</parameter> is 1.</para>

	<note>
	  <para>In above example you may notice that the first
	  call of <methodname>step</methodname>() doesn't cause the
	  time to change.  The simulator updates the time at the
	  beginning of the step, and calculates a tentative step size
	  after that.  The initial value of the step size is zero.
	  Thus it needs to call <methodname>step</methodname>() twice
	  to actually proceed the time.  See chapter 6 for details of
	  the simulation mechanism.</para>
	</note>

	<para>To execute the simulation for some seconds, call
	<methodname>run</methodname> method with a duration in
	seconds.  (e.g. <methodname>run</methodname>(
	<constant>10</constant> ) for 10 seconds.)
	<methodname>run</methodname> method steps the simulation
	repeatedly, and stops when the time is proceeded for the given
	seconds. In other words, the meaning of
	<methodname>run</methodname>( <parameter>10</parameter> ) is
	to run the simulation <emphasis>at least</emphasis> 10
	seconds.  It can overrun the specified length of time if the
	time step interval taken by </para>


	<note>
	  <para>The system supports <methodname>run</methodname>
	  without an argument to run forever, only if both
	  <emphasis>event checker</emphasis> and <emphasis>event
	  handler</emphasis> are set.  If not, it raises an exception.
	  See <methodname>setEventChecker</methodname>() in the method
	  list of Session class below.
	  </para>
	</note>

      </sect3>
	
      <sect3>
	<title>Getting current time</title>

	<para>To get the current time of the simulator,
	<methodname>getCurrentTime</methodname>() method can be used.</para>

	<informalexample><screen>
<prompt>simple.eml, t=10.0032>>> </prompt><userinput>getCurrentTime()</userinput>
<computeroutput>10.003221620379463</computeroutput>
</screen>
	</informalexample>

      </sect3>
      
      <sect3>
	<title>Printing messages</title>

	<para>You may want to print some messages in your ESS.
        Use <methodname>message</methodname>( <parameter>message</parameter> )
	method, where <parameter>message</parameter> argument is a
	string to be outputed.</para>

	<para>By default the message is handled in a way the same as
         the Python's <methodname>print</methodname> statement; it is
         printed out to the standard out with a trailing new line.
         This behavior can be changed by using
         <methodname>setMessageMethod</methodname>() method.</para>

      </sect3>


      <sect3>
	<title>An example of using <classname>Session</classname> methods</title>

	<para>Here is a tiny example of using
	<classname>Session</classname> methods which loads a model,
	run a hundred seconds, and print a short message.

<example>
	    <title>A simple <acronym>ESS</acronym> example.</title>
	    
	    <programlisting linenumbering="numbered">loadModel( 'simple.eml' )
run( 100 )
message( 'stopped at %f seconds.' % getCurrentTime() )
</programlisting>
	  </example>
        </para>
	
      </sect3>



    </sect2>

    <sect2>
      <title>Getting Session Parameters.</title>

      <para>Session parameters are given to an ESS as global variables.
      Therefore usage of the session parameters is very simple.  For
      example, if you can assume a session parameter
      <varname>MODELFILE</varname> is given, just use it as a
      variable:
<informalexample>
	  <programlisting>loadModel( MODELFILE )</programlisting>
	</informalexample>
      </para>

      <para>To check what parameters are given to ESS, use
      <methodname>dir</methodname>() or
      <methodname>globals</methodname>() built-in functions.  Session
      parameters are listed as well as other available methods and
      variables.   To check if a certain ESS parameter or a global variable is given, write an if statement like this:
<informalexample>
	  <programlisting>if 'MODELFILE' in globals():
    # MODELFILE is given
else:
    # not given</programlisting>
	</informalexample>

</para>


      <note>
	<para>Currently there is no way to distinguish the Session
      parameters from other global variables from within ESS.</para>
      </note>


    </sect2>


    <sect2>
      <title>Observing and Manipulating the Model with <classname>ObjectStub</classname>s</title>

      <sect3>
	<title>What is <classname>ObjectStub</classname>?</title>

	<para><classname>ObjectStub</classname> is a proxy object in
	the frontend side of the system which corresponds to an
	internal object in the simulator.  Any operations on the simulator's
	internal objects should be done via the
	<classname>ObjectStub</classname>.</para>


	<para>There are three types of
	<classname>ObjectStub</classname>:
<itemizedlist>
	    <listitem>
	      <para><classname>EntityStub</classname></para>
	    </listitem>
	    <listitem>
	      <para><classname>StepperStub</classname></para>
	    </listitem>
	    <listitem>
	      <para><classname>LoggerStub</classname></para>
	    </listitem>
	  </itemizedlist>

	each correspond to
	<classname>Entity</classname>, <classname>Stepper</classname>,
	and <classname>Logger</classname> classes in the simulator,
	respectively.</para>

      </sect3>


      <sect3>
	<title>Why <classname>ObjectStub</classname> is needed</title>


	<para><classname>ObjectStub</classname> classes are actually
	thin wrappers over the
	<classname>ecell.ecs.Simulator</classname> class of the E-Cell
	Python Library, which provides object-oriented appearance to
	the flat API of the class.  Although
	<classname>Simulator</classname> object can be accessed
	directly via <varname>theSimulator</varname> property of
	<classname>Session</classname> class, use of
	<classname>ObjectStub</classname> is encouraged.</para>

	<para>This backend / frontend isolation is needed because
        lifetimes of backend objects are not the same as frontend
        object, nor are their state transitions necessarily
        synchronous.  If the frontend directly manipulates the
        internal objects of the simulator, consistence of the lifetime
        and the state of the objects can easily be violated, which
        must not happen, without some complicated and tricky software
        mechanism.</para>

      </sect3>




      <sect3>
	<title>Creating an <classname>ObjectStub</classname> from ID</title>

	<para>To get an <classname>ObjectStub</classname> object,
	<methodname>createEntityStub</methodname>(),
	<methodname>createStepperStub</methodname>(), and
	<methodname>createLoggerStub</methodname>() methods of
	<classname>Session</classname> class are used.</para>

	<para>For example, to get an <classname>EntityStub</classname>,
	call the <methodname>createEntityStub</methodname>() method
	with a <emphasis>FullID</emphasis> string:</para>

	<informalexample>
	  <programlisting><varname>anADPStub</varname> = createEntityStub( <replaceable>'Variable:/CELL/MT1:ADP'</replaceable> )</programlisting>
	</informalexample>

	<para>Similarly, a <classname>StepperStub</classname> object
	and a <classname>LoggerStub</classname> object can be retrieved
	with a <emphasis>StepperID</emphasis> and a
	<emphasis>FullPN</emphasis>, respectively.</para>

	<informalexample>
	  <programlisting><varname>aStepperStub</varname> = createStepperStub( <replaceable>'STEPPER_01'</replaceable> )</programlisting> 

	  <programlisting><varname>aLoggerStub</varname> = createLoggerStub( <replaceable>'Variable:/CELL/MT1:GLUCOSE:Concentration' </replaceable> )</programlisting>
	</informalexample>


      </sect3>


      <sect3>
	<title>Creating and checking existence of a backend object</title>

	<para>Creating an <classname>ObjectStub</classname> doesn't
	necessarily mean a corresponding object in the backend exists, or is
	created.  In other words, creation of the
	<classname>ObjectStub</classname> is purely a frontend
	operation.  After creating an
	<classname>ObjectStub</classname>, you may want to check if
	the corresponding backend object exists, and/or to command the
	backend to create the backend object.</para>

	<para>To check if a corresponding object to an
	<classname>ObjectStub</classname> exists in the simulator, use
	<methodname>isExist</methodname>() method.  For example, the
	following if statement checks if a Stepper whose ID is
	<literal>STEPPER_01</literal> exists:
<informalexample>
	    <programlisting>aStepperStub = createStepperStub( 'STEPPER_01' )
if aStepperStub.isExist():
    # it already exists
else:
    # it isn't created yet</programlisting>
	  </informalexample>
	</para>

	<para>To create the backend object, just call
	<methodname>create</methodname>() method.
<informalexample>
<programlisting>aStepperStub.create()<lineannotation># Stepper 'STEPPER_01' is created here</lineannotation>
</programlisting>
	  </informalexample></para>

      </sect3>

      <sect3>
	<title>Getting the name and a class name from an <classname>ObjectStub</classname></title>

	<para>To get the name (or an ID) of an
	<classname>ObjectStub</classname>, use
	<methodname>getName</methodname>() method.</para>

	<para>To get the class name of an
	<classname>EntityStub</classname> or a
	<classname>StepperStub</classname>, call
	<methodname>getClassName</methodname>() method.  This
	operation is not applicable to
	<classname>LoggerStub</classname>.</para>

      </sect3>



      <sect3>
	<title>Setting and getting properties</title>

	<para>As described in the previous chapters,
	<classname>Entity</classname> and
	<classname>Stepper</classname> objects has
	<emphasis>properties</emphasis>.  This section describes how
	to access the object properties via
	<classname>ObjectStub</classname>s.  This section is not
	applicable to <classname>LoggerStub</classname>s.</para>

	<para>To get a property value from a backend object by using
	an <classname>EntityStub</classname> or a
	<classname>StepperStub</classname>, invoke
	<methodname>getProperty</methodname>() method or access an
	object attribute with a
	property name:
<informalexample>
	    <programlisting>aValue = aStub.getProperty( 'Activity' )</programlisting></informalexample>
or equivalently,
<informalexample>
	    <programlisting>aValue = aStub[ 'Activity' ]</programlisting>
	  </informalexample></para>

	<para>To set a new property value to an
	<classname>Entity</classname> or a
	<classname>Stepper</classname>, call
	<methodname>setProperty</methodname>() method or mutate an
	object attribute with a	property name and the new value:
<informalexample>
<programlisting>aStub.getProperty( 'Activity', aNewValue )</programlisting> 
	  </informalexample>
or equivalently, 
<informalexample>
<programlisting>aStub[ 'Activity' ] = aNewValue</programlisting>
	  </informalexample>
</para>

	<para>List of all the properties can be gotten by using
	<methodname>getPropertyList</methodname> method, which returns
	a list of property names as a Python
	<type>tuple</type> containing string objects.
<informalexample>
	    <programlisting>aStub.getPropertyList()</programlisting>
	  </informalexample>
</para>

	<para>To know if a property is <emphasis>getable</emphasis>
	(accessible) or <emphasis>setable</emphasis> (mutable), call
	<methodname>getPropertyAttribute</methodname>() with the name
	of the property.  The method returns a Python
	<type>tuple</type> whose first element is true if the property
	is setable, and the second element is true if it is getable.
	Attempts to get a value from an inaccessible property and to
	set a value to a immutable property result in
	exceptions.
<informalexample>
	    <programlisting>aStub.getPropertyAttribute( 'Activity' )[0] <lineannotation># <constant>true</constant> if setable</lineannotation>
aStub.getPropertyAttribute( 'Activity' )[1] <lineannotation># <constant>true</constant> if getable</lineannotation></programlisting>
	  </informalexample>
</para>

      </sect3>

      <sect3>
	<title>Getting <classname>Logger</classname> data</title>

	<para>To get logged data from a <classname>LoggerStub</classname>,
 use <methodname>getData</methodname>() method.</para>

	<para><methodname>getData</methodname>() method has three forms according to requested range and time resolution of the data:
<itemizedlist>
	    <listitem>
	      <para>getData()</para>
	      <para>Get the whole data.</para>
	    </listitem>
	    <listitem>
	      <para>getData( <parameter>starttime</parameter>
	      <optional>, <parameter>endtime</parameter></optional>
	      )</para> <para>Get a slice of the data from
	      <parameter>starttime</parameter> to
	      <parameter>endtime</parameter>.  If
	      <parameter>endtime</parameter> is omitted, the slice
	      includes the tail of the data.</para>
	    </listitem>
	    <listitem>
	      <para>getData( <parameter>starttime</parameter>,
	      <parameter>endtime</parameter>,
	      <parameter>interval</parameter> )</para> <para>Get a
	      slice of the data from <parameter>starttime</parameter>
	      to <parameter>endtime</parameter>.  This omits data
	      points if a time interval between two datapoints is
	      smaller than <parameter>interval</parameter>.  This is
	      not suitable for scientific data analysis, but optimized
	      for speed.</para>
	    </listitem>
	  </itemizedlist>
	<methodname>getData</methodname>() method returns a rank-2 (matrix)
	<classname>array</classname> object of <productname>Numeric
	Python</productname> module.  The <type>array</type> has
	either one of the following forms:
<informalexample>
	    <programlisting>[ [ time value average min max ]
  [ time value average min max ]
... ] </programlisting>
	  </informalexample>
or
<informalexample>
	    <programlisting>[ [ time value ]
  [ time value ]
... ] </programlisting>
	  </informalexample>
The first five-tuple data format has five values in a single datapoint:

<itemizedlist>
	    <listitem>
	      <para>time</para>
	      <para>The time of the data point.</para>
	    </listitem>
	    <listitem>
	      <para>value</para>
	      <para>The value at the time point.</para>
	    </listitem>
	    <listitem>
	      <para>average</para>
	      <para>The time-weighted average of the value after the last data point to the time of this data point.</para>
	    </listitem>
	    <listitem>
	      <para>min</para>
	      <para>The minimum value after the last data point to the time of this data point.</para>
	    </listitem>
	    <listitem>
	      <para>max</para>
	      <para>The maximum value after the last data point to the time of this data point.</para>
	    </listitem>
	  </itemizedlist>
The two-tuple data format has only time and value.
</para>




	<para>To know the start time, the end time, and the size of
the logged data before getting data, use
<methodname>getStartTime</methodname>(),
<methodname>getEndTime</methodname>(), and
<methodname>getSize</methodname>() methods of
<classname>LoggerStub</classname>.  <methodname>getSize</methodname>() returns the number of data points stored in the <classname>Logger</classname>.</para>


      </sect3>

      <sect3>
	<title>Getting and changing logging interval</title>
	<para>Logging interval of a <classname>Logger</classname> can
	be checked and changed by using
	<methodname>getMinimumInterval</methodname>() and
	<methodname>setMinimumInterval</methodname>(
	<parameter>interval</parameter> ) methods of
	<classname>LoggerStub</classname>.
	<parameter>interval</parameter> must be a zero or positive
	number in second.  If <parameter>interval</parameter> is a non-zero
	positive number, the <classname>Logger</classname> skips
	logging if a simulation step occurs before
	<parameter>interval</parameter> second past the last logging
	time point.  If <parameter>interval</parameter> is zero, the
	<classname>Logger</classname> logs at every simulation step.</para>
      </sect3>

      <sect3>
	<title>An Example usage of an <classname>EntityStub</classname></title>

	<para>The following example loads an EML file, and prints the
	value of ATP <classname>Variable</classname> in
	<classname>System</classname> <constant>/CELL</constant> every
	10 seconds.  If the value is below 1000, it stops the simulation.
</para>
	<example>
	  <title>An <acronym>ESS</acronym> to check ATP level every 10 seconds</title>
	  
	  <programlisting linenumbering="numbered">loadModel( 'simple.eml' )

ATP = createEntityStub( 'Variable:/CELL:ATP' )

while 1:

    ATPValue = ATP[ 'Value' ]

    message( 'ATP value = %s' % ATPValue )

    if ATPValue <= 1000:
        break

    run( 10 )

message( 'Stopped at %s.' % getCurrentTime() )
</programlisting>
	</example>

      </sect3>

    </sect2>

    <sect2>
      <title>Handling Data Files</title>

      <sect3>
	<title>About <acronym>ECD</acronym> file</title>

	<para>&ecell SE uses <acronym>ECD</acronym> (E-Cell Data) file
format to store simulation results. <acronym>ECD</acronym> is a plain
text file, and easily handled by user-written and third-party data
processing and plotting software such as
<productname>gnuplot</productname>.</para>

	<para>An <acronym>ECD</acronym> file can store a matrix of
	floating-point numbers.</para>

	<para><classname>ecell.ECDDataFile</classname> class can be
used to save and load <acronym>ECD</acronym> files.  A
<classname>ECDDataFile</classname> object takes and returns a rank-2
<type>array</type> of <productname>NumericPython</productname>.  A
'rank-2' <type>array</type> is a matrix, which means that
<methodname>Numeric.rank( ARRAY )</methodname> and <methodname>len(
Numeric.shape( ARRAY ) )</methodname> returns
'<constant>2</constant>'.</para>

      </sect3>

      <sect3>
	<title>Saving and loading data</title>
	
	<para>To save data to an <acronym>ECD</acronym> file, say,
	<filename>datafile.ecd</filename>, instantiate an
	<classname>ECDDataFile</classname> object and use
	<methodname>save</methodname>() method.
	<informalexample>
	  <programlisting>import ecell
aDataFile = ecell.ECDDataFile( DATA )
aDataFile.save( 'datafile.ecd' )
</programlisting>
	  </informalexample>
          here <varname>DATA</varname> is a rank-2 <type>array</type>
          of <productname>Numeric Python</productname> or an
          equivalent object.  The data can also be set by using
          <methodname>setData</methodname>() method after the
          instantiation.  If the data is already set, it is replaced.
<informalexample>
	    <programlisting>aDataFile.setData( DATA )</programlisting>
	  </informalexample>


 </para>

	<para>Loading the <acronym>ECD</acronym> file is also straightforward.
<informalexample>
	    <programlisting>aDataFile = ecell.ECDDataFile()
aDataFile.load( 'datafile.ecd' )
DATA = aDataFile.getData()</programlisting>
	  </informalexample>
The <methodname>getData</methodname>() method extracts the data from the <classname>ECDDataFile</classname> object as an <type>array</type>.
</para>

      </sect3>

      <sect3>
	<title><acronym>ECD</acronym> header information</title>
	<para>In addition to the data itself, an <acronym>ECD</acronym> file can hold some information in its header.
<itemizedlist>
	    <listitem>
	      <para>Data name</para>
	      <para>The name of data.  Setting a <emphasis>FullPN</emphasis> may be a good idea.  Use <methodname>setDataName</methodname>( <parameter>name</parameter> ) and <methodname>getDataName</methodname>() methods to set and get this field.</para>
	    </listitem>
	    <listitem>
	      <para>Label</para> <para>This field is used to name axes
	      of the data. Use <methodname>setLabel</methodname>(
	      <parameter>labels</parameter> ) and
	      <methodname>getLabel</methodname>() methods.  These
	      methods takes and returns a
	      <productname>Python</productname> <type>tuple</type>,
	      and stored in the file as a space-separated list. The default value of this field is: <constant>( 't', 'value', 'avg', 'min', 'max' )</constant>.</para>
	    </listitem>
	    <listitem>
	      <para>Note</para> <para>This is a free-format field.
	      This can be a multi-line or a single-line string.  Use
	      <methodname>setNote</methodname>(
	      <parameter>note</parameter> ) and
	      <methodname>getNote</methodname>().</para>
	    </listitem>
	  </itemizedlist>
</para>

	<para>The header information is stored in the file like this.
<programlisting>
#DATA:
#SIZE: 5 1010
#LABEL: t       value   avg     min     max
#NOTE:
#
#----------------------
0 0.1 0.1 0.1 0.1
...
</programlisting>
Each line of the header is headed by a sharp (#) character.  The
<constant>'#SIZE:'</constant> line is automatically set when saved to
show size of the data.  This field is ignored in loading.  The header
ends with <constant>'#----...'</constant>.
</para>

      </sect3>

      <sect3>
	<title>Using <acronym>ECD</acronym> outside &ecell SE</title>

	<para>For most cases <productname>Numeric Python</productname>
	will offer any necessary functionality for scientific data
	processing.  However, using some external software can enhance
	the usability.</para>

	<para><acronym>ECD</acronym> files can be used as input to any
	software which supports white space-separated text format, and
	treats lines with heading sharps (#) as comments.</para>

	<para><productname>GNU gnuplot</productname> is a scientific
	presentation-quality plotting software with a sophisticated
	interactive command system.  To plot an <acronym>ECD</acronym>
	file from <productname>gnuplot</productname>, just use
	<command>plot</command> command. For example, this draws a
	time-value 2D-graph:
<informalexample>
	    <screen><prompt>gnuplot> </prompt><userinput>plot 'datafile.ecd' with lines</userinput>
</screen>
	  </informalexample>
	    Use <command>using</command> modifier to specify which column to use for the plotting. The following example makes a time-average 2D-plot.
<informalexample>
	    <screen><prompt>gnuplot> </prompt><userinput>plot 'datafile.ecd' using 1:3 with lines</userinput>
</screen>
	  </informalexample>
</para>
	<para>Another OpenSource software useful for data processing is GNU <productname>Octave</productname>.  Loading an <acronym>ECD</acronym> from <productname>Octave</productname> is also simplest.
<informalexample>
	    <screen><prompt>octave:1></prompt> <userinput>load datafile.ecd</userinput></screen>
	  </informalexample>
Now the data is stored in a matrix variable with the same name as the file without the extension (<varname>datafile</varname>).
<informalexample>
	    <screen><prompt>octave:2> </prompt><userinput>mean(datafile)</userinput>
<computeroutput>ans =
 
   5.0663  51.7158  51.7158  51.2396  52.2386</computeroutput>
</screen>
	  </informalexample>
</para>

      </sect3>

      <sect3>
	<title>Binary format</title>

	<para>Currently loading and saving of the binary file format
	is not supported.</para>
      </sect3>


    </sect2>

    <sect2>
      <title>Other Methods</title>
      <sect3>
	<title>Getting version numbers</title>

	<para><methodname>getLibECSVersion</methodname>() method of
	<classname>ecell.ecs</classname> module gives the version of
	the C++ backend library
	(libecs) as a string. <methodname>getLibECSVersionInfo</methodname>()
	method of the module gives the version as a
	<productname>Python</productname> <type>tuple</type>.  The
	<type>tuple</type> contains three numbers in this order: (
	<parameter>MAJOR_VERSION</parameter>,
	<parameter>MINOR_VERSION</parameter>,
	<parameter>MICRO_VERSION</parameter> )</para>

	<informalexample>
	  <screen><prompt>ecell3-session>>> </prompt><userinput>import ecell</userinput>
<prompt>ecell3-session>>> </prompt><userinput>ecell.ecs.getLibECSVersion()</userinput>
<computeroutput>'3.2.0'</computeroutput>
<prompt>ecell3-session>>> </prompt><userinput>ecell.ecs.getLibECSVersionInfo()</userinput>
<computeroutput>(3, 2, 0)</computeroutput>
</screen>
	</informalexample>

      </sect3>

      <sect3>
	<title><acronym>DM</acronym> loading-related methods</title>

	<para>The search path of <acronym>DM</acronym> files can be
	specified and retrieved by using
	<methodname>setDMSearchPath</methodname>() and
	<methodname>getDMSearchPath</methodname>() methods.  These
	methods gets and returns a colon (:) separated list of
	directory names.  The search path can also be specified by
	using <varname>ECELL3_DM_PATH</varname> environment
	variable. See the previous section for more about
	<acronym>DM</acronym>search path.</para>

	<informalexample>
	  <screen><prompt>ecell3-session>>> </prompt><userinput>import ecell</userinput>
<prompt>ecell3-session>>> </prompt><userinput>ecell.ecs.setDMSearchPath( '~/dm:~/test/dm' )</userinput>
<prompt>ecell3-session>>> </prompt><userinput>ecell.ecs.getDMSearchPath()</userinput>
<computeroutput>'~/dm:~/test/dm'</computeroutput>
</screen>
	</informalexample>

	<para>A list of built-in and already loaded
	<acronym>DM</acronym> classes can be gotten with
	<methodname>getDMInfo</methodname>() method of
	<classname>ecell.ecs.Simulator</classname> class.  The
	<classname>Simulator</classname> instance is available to
	<classname>Session</classname> as
	<varname>theSimulator</varname> variable.  The method returns
	a nested <productname>Python</productname> <type>tuple</type>
	in the form of ( ( TYPE1, CLASSNAME1, PATH1 ), ( TYPE2,
	CLASSNAME2, PATH2 ), ... ).  TYPE is one of
	<constant>'Process'</constant>,
	<constant>'Variable'</constant>,
	<constant>'System'</constant>, or
	<constant>'Stepper'</constant>.  CLASSNAME is the class name
	of the <acronym>DM</acronym>.  PATH is the directory from
	which the <acronym>DM</acronym> is loaded.  PATH is an empty
	string (<constant>''</constant>) if it is a built-in class.</para>

	<informalexample>
	  <screen>
<prompt>ecell3-session>>> </prompt><userinput>theSimulator.getDMInfo()</userinput>
<computeroutput>(('Process', 'GillespieProcess', '/usr/lib/ecell/3.2/GillespieProcess.so'), 
('Stepper', 'DiscreteTimeStepper', ''), 
('Stepper', 'NRStepper', '/usr/lib/ecell/3.2/NRStepper.so'), ... )</computeroutput>
</screen>
	</informalexample>


      </sect3>
    </sect2>


  </sect1>

  <sect1>
    <title>Advanced Topics</title>

    <sect2>
      <title>How <command>ecell3-session</command> runs</title>

      <para><command>ecell3-session</command> command runs on
	<command>ecell3</command> interpreter command.
	<command>ecell3</command> command is a thin wrapper to the
	<productname>Python</productname> interpreter.
	<command>ecell3</command> command simply invokes a
	<productname>Python</productname> interpreter command
	specified at compile time.  Before executing
	<productname>Python</productname>, <command>ecell3</command>
	sets some environment variables to ensure that it can find
	necessary &ecell <productname>Python</productname> extension
	modules and the Standard <acronym>DM</acronym> Library. 
	After processing the commandline options,
	<command>ecell3-session</command> command creates an
	<classname>ecell.ecs.Simulator</classname> object, and then
	instantiate a <classname>ecell.Session</classname> object for
	the simulator object.  </para>

      <para>Thus basically <command>ecell3</command> is just a
	<productname>Python</productname> interpreter, and frontend
	components to &ecell SE should run on this command.  To use
	the &ecell Python Library from <command>ecell3</command>
	command, use <programlisting>import ecell</programlisting>
	statement from the prompt:
<informalexample>
	  <screen><prompt>$ </prompt><userinput>ecell3</userinput> 
<computeroutput>Python 2.2.2 (#1, Feb 24 2003, 19:13:11)
[GCC 3.2.2 20030222 (Red Hat Linux 3.2.2-4)] on linux2
Type "help", "copyright", "credits" or "license" for more information.</computeroutput>
<prompt>>>> </prompt><userinput>import ecell</userinput>
<prompt>>>> </prompt>
</screen>
	</informalexample>
or, (on UNIX-like systems) execute a file starting with:
<programlisting>#!/usr/bin/env ecell3
import ecell
[...]
</programlisting> 
	</para>


    </sect2>


    <sect2>
      <title>Getting information about execution environment</title>

      <para>To get the current configuration of
	<command>ecell3</command> command, invoke
	<command>ecell3</command> command with a
	<parameter>-h</parameter> option. This will print values of
	some variables as well as usage of the command.
<informalexample>
	  <screen><prompt>$ </prompt><userinput>ecell3 -h</userinput>
<computeroutput>[...]

Configurations:
 
        PACKAGE         = ecell
        VERSION         = 3.2.0
        PYTHON          = /usr/bin/python
        PYTHONPATH      = /usr/lib/python2.2/site-packages:
        DEBUGGER        = gdb
        LD_LIBRARY_PATH = /usr/lib:
        prefix          = /usr
        pythondir       = /usr/lib/python2.2/site-packages
        ECELL3_DM_PATH  =

[...]
</computeroutput></screen>
	</informalexample>
The '<computeroutput>PYTHON =</computeroutput>' line gives the path of the
<productname>Python</productname> interpreter to be used.
</para>
    </sect2>

    <sect2>
      <title>Debugging</title>

      <para>To invoke <command>ecell3</command> command in debugging
	mode, set <varname>ECELL_DEBUG</varname> environment variable.
	This runs the command on a debugger software.  If found,
	<productname>GNU gdb</productname> is used as the
	debugger. <varname>ECELL_DEBUG</varname> can be used for any
	commands run on <command>ecell3</command>, including
	<command>ecell3-session</command> and
	<command>gecell</command>.  For example, to run <command>ecell3-session</command> in debug mode on the shell prompt:
<informalexample>
	  <screen><prompt>$ </prompt><userinput>ECELL_DEBUG=1 ecell3-session -f foo.eml</userinput>
<computeroutput>gdb --command=/tmp/ecell3.0mlQyE /usr/bin/python
GNU gdb Red Hat Linux (5.3post-0.20021129.18rh)
Copyright 2003 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.  Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux-gnu"...
[New Thread 1074178112 (LWP 7327)]
ecell3-session [ E-Cell SE Version 3.2.0, on Python Version 2.2.2 ]
Copyright (C) 1996-2003 Keio University.
Send feedback to Kouichi Takahashi &lt;shafi@e-cell.org></computeroutput>
<prompt>&lt;foo.eml, t=0>>> </prompt><userinput><keycombo action='simul'>
		<keycap>Ctrl</keycap>
		<keycap>C</keycap>
	      </keycombo></userinput>
<computeroutput>Program received signal SIGINT, Interrupt.
[Switching to Thread 1074178112 (LWP 7327)]
0xffffe002 in ?? ()</computeroutput>
<prompt>(gdb)</prompt>
</screen>
	</informalexample>
It automatically runs the program with the commandline options with '<parameter>--command=</parameter>' option of <productname>gdb</productname>.  The <productname>gdb</productname> prompt appears when the program crashes or interrupted by the user by pressing <keycombo action='simul'>
	  <keycap>Ctrl</keycap>
	  <keycap>C</keycap>
	</keycombo>.
</para>

      <para><varname>ECELL_DEBUG</varname> runs
	<productname>gdb</productname>, which is for debugging at the
	level of lower level C++ code.  See
	<productname>Python</productname> Library Reference Manual for
	<productname>Python Debugger</productname>.</para>
    </sect2>


    <sect2>
      <title>Profiling</title>

      <para>It is possible to run <command>ecell3</command> command
	in profiling mode, if the operating system has
	<productname>GNU sprof</productname> command, and its C
	library supports <varname>LD_PROFILE</varname> environmental
	variable.  Currently it only supports per-shared object
	profiling. (See GNU C Library Reference Manual)</para>

      <para>To run <command>ecell3</command> in profiling mode, set
	<varname>ECELL_PROFILE</varname> environment variable to
	<emphasis>SONAME</emphasis> of the shared object.  SONAME of
	a shared object file can be found by using
	<productname>objdump</productname> command, with, for example,
	<parameter>-p</parameter> option.</para>

      <para>For example, the following commandline takes a
	performance profile of Libecs:
<informalexample>
	  <screen><prompt>$ </prompt><userinput>ECELL_PROFILE=libecs.so.2 ecell3-session [...]</userinput></screen>
	</informalexample>
        After running, it creates a profiling data file with a
        filename <filename>SONAME.profile</filename> in the
        <emphasis>current directory</emphasis>.  In this case, it is
        <filename>libecs.so.2.profile</filename>.  The binary
        profiling data can be converted to a text format by using
        <command>sprof</command> command. For example:
        <informalexample> <screen><prompt>$ </prompt><userinput>sprof -p libecs.so.2</userinput></screen>
	</informalexample>
</para>


    </sect2>

  </sect1>



  <sect1>
    <title>&ecell Python Library API</title>

    <para>This section provides a list of some commonly used 
      classes in &ecell Python library and their APIs.
      </para>


    <sect2>
      <title>Method List of <classname>Session</classname> Class</title>

      <para>Methods of <classname>Session</classname> class has
      the following five groups.</para>

      <itemizedlist>
	<listitem>
	  <para>Session methods</para>
	</listitem>
	<listitem>
	  <para>Simulation methods</para>
	</listitem>
	<listitem>
	  <para>Stepper methods</para>
	</listitem>
	<listitem>
	  <para>Entity methods</para>
	</listitem>
	<listitem>
	  <para>Logger methods</para>
	</listitem>
      </itemizedlist>


      &session-class-api


    </sect2>

    <sect2>
      <title>Method List of <classname>ObjectStub</classname> Classes</title>


      <para>There are three subclasses of <classname>ObjectStub</classname>
</para>
      <itemizedlist>
	<listitem>
	  <para><classname>EntityStub</classname></para>
	</listitem>
	<listitem>
	  <para><classname>StepperStub</classname></para>
	</listitem>
	<listitem>
	  <para><classname>LoggerStub</classname></para>
	</listitem>
      </itemizedlist>

      <para>Some methods are common to these subclasses.</para>




      &objectstubs-api

    </sect2>

    <sect2>
      <title>Method List of <classname>ECDDataFile</classname> Class</title>
      <para><classname>ECDDataFile</classname> class has the following set of methods.</para>

      &ecddatafile-api
    </sect2>


  </sect1>

  


</chapter>

<!--
Local Variables:
mode: sgml
sgml-parent-document: ("ecell3-users-manual.xml" "book" "chapter")
End:
-->

