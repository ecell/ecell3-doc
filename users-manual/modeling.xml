  <!-- ================ Writing em ================================ -->

  <chapter id="modeling"> 
  <title>Modeling with &ecell;</title> 

  <highlights>
    <para>By reading this chapter, you can get information about:</para>
    
    <simplelist>
      <member>How an &ecell;'s simulation model is organized.</member>
      <member>How to create a simulation model.</member>
      <member>How to write a model file in &EM; format.</member>
    </simplelist>
  </highlights>


  <sect1>
    <title>Simulation Model Of &ecell;</title>

    <para>
    &ecell;'s simulation model is fully object-oriented.  That is, the
    simulation model is actually a set of <emphasis>objects</emphasis>
    connected each other.  The objects have
    <emphasis>properties</emphasis>, which determine characteristics
    of the objects (such as a reaction rate constant if the object
    represent a chemical reaction) and the relationships between
    objects.
    </para>

    <sect2>
      <title>Objects In The Model</title>

      <para>A simulation model of &app; consists of the following types of objects.
<itemizedlist>
	  <listitem>
	    <para>Usually more than one &Entity; object</para>
	  </listitem>
	  <listitem>
	    <para>One or more &Stepper; object(s)</para>
	  </listitem>
	</itemizedlist>
&Entity; objects define the structure of the simulation model and represented phenomena (such
as chemical reactions) in the model. &Stepper; objects
implement specific simulation algorithms.
</para>
  </sect2>


    <sect2>
      <title>&Entity; Objects</title>

      <para>
The &Entity; class has three subclasses:
<itemizedlist>
	  <listitem>
	    <para>&Variable</para> <para>This class of objects represent state
	  variables.  A &Variable; object holds a scalar real-number
	  value.  A set of values of all &Variable; objects in a
	  simulation model defines the state of the model at a certain
	  point in time.</para>
	  </listitem>
	  <listitem>
	    <para>&Process</para> <para>This class of objects
	  represent phenomena in the simulation model that result in
	  changes in the values of one or more &Variable; objects.
	  The way of change of the &Variable; values can be either
	  discrete or continuous.</para>
	  </listitem>
	  <listitem>
	    <para>&System</para> <para>This class of objects define
	  overall structure of the model.  A &System; object can
	  contain sets of these three types of &Entity;, &Variable;,
	  &Process;, and &System; objects.  A &System; can contain
	  other &System;s, and can form a tree-like structure.  
	  </para>
	  </listitem>
	</itemizedlist>
</para>
      <sect3>
	<title>Root &System;</title>
	<para>When a simulator instance is newly instantiated, 
	a subclass object of &System;,
	a <classname>CompartmentSystem</classname>, is created, and named '/'.
        This &System; is called the <emphasis>root &System</emphasis>.
</para>
      </sect3>


    </sect2>

    <sect2>
      <title>&Stepper; Objects</title>

      <para>A model must have one or more &Stepper; object(s).  Each
      &Process; and &System; object must be connected with a &Stepper;
      object in the same model.  In other words, &Stepper; objects in
      the model have non-overlapping sets of &Process; and &System;
      objects.</para>

      <para>&Stepper; is a class which implement a specific simulation
      algorithm.  If the model has more than one &Stepper; objects,
      the system conducts a multi-algorithm (or multi-stepper)
      simulation.  In addition to the lists of &Process; and &System;
      objects, a &Stepper; has a list of &Variable; objects that can
      be read or written by its &Process; objects.  It also has a time
      step interval as a positive real-number.  The system schedules
      &Stepper; objects according to the step intervals, and updates
      the current time. When called by the system, a &Stepper; object
      updates values of related &Variable; objects, calls zero, one or
      more &Process; objects connected with the &Stepper; in an order
      determined by its implementation of the algorithm, and
      determines the next time step interval.  See the following
      chapters for details of the simulation procedure.</para>

      <para></para>
    </sect2>




    <sect2>
      <title>Object Identifiers</title>

      <para>&app; uses several types of identifier strings to specify
      an object, such as the &Entity; and &Stepper;, in a simulation
      model.</para>

      <sect3>
	<title>ID (&EntityID; and &StepperID;)</title>

	<para>Every &Entity; and &Stepper; object has an
	<emphasis>ID</emphasis>.  An ID is a character string of
	arbitrary length starting from an alphabet or '_' with
	succeeding alphabet, '_', and numeric characters.  &app treats
	IDs in a case-sensitive way.</para>

	<para>If the ID is used to indicate a &Stepper; object, it is
	called a &StepperID;.  The ID points to an &Entity; object is
	refered to as &EntityID;, or just
	<emphasis>ID</emphasis>.</para>

	<para>(need EBNF here)</para>

	<informalexample>
	  <para>Examples: _P3, ATP, GlucoKinase</para>
	</informalexample>

      </sect3>

      <sect3>
	<title>&SystemPath;</title>

	<para>The &SystemPath; identifies a &System; from the
	tree-like hierarchy of &System; objects in a simulation model.
	It has a form of &EntityID; strings joined by a character '/'
	(slash).  As a special case, the &SystemPath; of the root
	system is '/'. For instance, if there is a &System; 'A', and
	'A' has a subsystem 'B', a &SystemPath; '/A/B' specifies the
	&System; object 'B'.  It has three parts: (1) the root system
	('/'), (2) the &System; 'A' directly under the root system,
	and (3) the &System; 'B' just under 'A'.</para>

	<para>A &SystemPath can be relative.  That is, it can contain
	'.' and '..' to specify a current and a super (containing)
	&System;, respectively.  If a &SystemPath; is relative, it does
	not point at a &System; object unless a current &System; is
	given.</para>

	<informalexample>
	  <para>Examples: /A/B,  ../A, ., /CELL/ER1/../CYTOSOL</para>
	</informalexample>

      </sect3>

      <sect3>
	<title>&FullID;</title>

	<para>A &FullID; identifies a unique &Entity; object in a simulation
	model.  A &FullID; comprises three parts, (1) a
	<emphasis>Type</emphasis>, (2) a &SystemPath;, and (3) an
	&EntityID;, joined by a character ':' (colon).</para>

	<para>Type is one of the following class names:
<itemizedlist>
	    <listitem>
	      <para>&System;</para>
	    </listitem>
	    <listitem>
	      <para>&Process;</para>
	    </listitem>
	    <listitem>
	      <para>&Variable;</para>
	    </listitem>
	  </itemizedlist>
</para>

	<para>For example, the following &FullID; points to a
&Process; object of which &EntityID; is 'P', in the &System; 'CELL'
directly under the root system.
<informalexample>
	    <programlisting>Process:/CELL:P</programlisting>
	  </informalexample>
</para>

      </sect3>

      <sect3>
	<title>&FullPN;</title>

	<para>&FullPN; specifies a unique
	<emphasis>property</emphasis> (see below) of an &Entity; object in the
	simulation model.  It has a form of a &FullID; and a name of a
	property joined by a character ':'.</para>

	<para>The following &FullPN; points to a 'Value' property of the &Variable; object 'Variable:/CELL:S'.
<informalexample>
	    <programlisting>Variable:/CELL:S:Value</programlisting>
	  </informalexample>
</para>
      </sect3>

    </sect2>



    <sect2>
      <title>Object Properties</title>

      <para>&Entity; and &Stepper; objects have
      <emphasis>properties</emphasis>.  Property is an attribute of a
      certain object associated with a name, which can be get from and
      set to an object.
      </para>

      <para>A value of a property has a <emphasis>type</emphasis>,
      which is one of the following types.

<itemizedlist>
	<title>Types of object properties</title>

	  <listitem>
	    <para>&Real; number</para> 
	    <para>(ex. 3.33e+10, 1.0)</para>
	  </listitem>
	  <listitem>
	    <para>&Int; number</para>
	    <para>(ex. 3, 100)</para>
	  </listitem>
	  <listitem>
	    <para>&StringType;</para>

	    <para>&StringType; has two forms: quoted and not quoted.
	    A quoted &StringType; can contain any
	    <acronym>ASCII</acronym> characters except the quotation
	    characters (' or ").  If a &StringType; is not quoted, it
	    can start with an alphabet character or '_', or '/', and
	    contain alphabets, numbers, '_', '/' and ':'.</para>

	    <para>Multi-line string support is currently under
	    development.</para>

	    <para>(ex. C10_A, "It can include spaces if double-quoted.", 'single-quote is available too, if you want to use "double-quotes" inside.')</para>
	  </listitem>

	  <listitem>
	    <para>List</para> <para>The list can contain &Real;,
	    &Int;, &StringType; values. This list can also contain
	    other lists, that is, the list can be nested.  A list must
	    be surrounded by brackets ('[' and ']'), and the elements
	    must be separated by space characters.  In some cases
	    outermost brackets are omitted (such as in &EM; files, see below).</para>
	    <para>(ex. [ A 10 [ 1.0 "a string" 1e+10 ] ] )</para>
	  </listitem>
	</itemizedlist>
</para>

      <sect3>
	<title>Dynamic type conversion of property values</title>

	<para>The system automatically convert the type of the
         property value if it is different from what the backend
         object (such as &Process; and &Variable;) expects to get.
         That is, the system does not necessary raise an error if the
         type of the given value differs from the type the backend
         object accepts.  The system always try to convert a type of
         the value given in a model file to a requested type by the
         backend object.  The conversion is done by the backend object,
         when it gets a property value.  See the
         following section.</para>

	<para>The conversion is done in the following manner.  
<itemizedlist>
	    <title>How property value type conversion is conducted</title>
	    <listitem>
	      <para>From a numeric value (&Real; or &Int;)</para>
	      <itemizedlist>
		<listitem>
		  <para>To a &StringType;</para> 

		  <para>The number is simply converted to a character
		  string. For example, a number 12.3 is converted to a
		  &StringType; '12.3'.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A numeric value can be converted to a length-1
		  list which has that number as the first item.  For
		  example, 12.3 is equivalent to '[ 12.3 ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a &StringType;</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric value (&Real; or &Int;)</para> 
		  
		  <para>The initial portion of the &StringType; is
                  converted to a numeric value.  The number can be
                  represented either in a decimal form or a
                  hexadecimal form.  Leading white space characters
                  are ignored.  'INF' and 'NAN' (case-insensitive) are
                  converted to an infinity and a NaN (not-a-number),
                  respectively.  If the initial portion of the
                  &StringType; cannot be converted to a numeric value,
                  it is interpreted as a zero (0.0 or 0).  This
                  conversion procedure is equivalent to C functions
                  <function>strtol</function> and
                  <function>strtod</function>, according to the
                  destined type.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A &StringType; can be converted to a length-1
		  list which has that &StringType; as the first item.  For
		  example, 'string' is equivalent to '[ 'string' ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a list</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric or a &StringType value</para> 

		  <para>It simply takes the first item of the list.
		  If necessary the taken value is further converted to
		  other types.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	  </itemizedlist>


<note>
	    <title>Overflow or underflow when converting a property
	    value</title> 

	    <para>When converting from a &Real; number to an &Int;, or
	    from a &StringType; to a numeric value, overflow or
	    underflow can occur during the conversion.  In this case
	    an exception (TYPE??) is raised when the backend object
	    attempts the conversion.</para>
	  </note>

</para>


      </sect3>


    </sect2>


  </sect1>


  <sect1>
    <title>E-Cell Model (&EM;) File Basics</title>

    <sect2>
      <title>What Is &EM;?</title>

      <para>
      In &app, the standard file format of model description and
      exchange is XML-based &EML; (E-Cell Model description Language).
      Although &EML; is an ideal means of integrating E-Cell with other
      software components such as GUI model editors and databases, it
      is very tedious for human users to write and edit by hand.</para>

      <para>E-Cell Model (&EM;) is a file
      format with a programming language-like syntax and a powerful
      embedded &empy; preprocessor, which is
      designed to be productive and intuitive especially when handled
      by text editors and other text processing programs such as
      UNIX's <application>grep</application>,
      <application>diff</application> and
      <application>cat</application>.  Semantics of &EM; and &EML; files
      are almost completely equivalent to each other, and going
      between these two formats is meant to be possible with no loss
      of information (some exceptions are comments and directions to
      the preprocessor in &EM;).  The file suffix of &EM; files must be
      ".em".
    </para>

    <sect3>
      <title>Why and when use &EM;?</title>

	<para>An &EM; file can be viewed as an &EML; generator script.
         

</para>

	<para>Although <application>E-Cell Modeling
         Environment</application> (which is under development) will
         provide means of more sophisticated, scalable and intelligent
         model construction on the basis of &EML;, learning syntax and
         semantics of &EM; may help you to get the idea of how object
         model inside &ecell is organized and how it is driven to
         conduct simulations.  Furthermore, owing to the nature of
         plain programming language-like syntax, &EM; can be used as a
         simple and intuitive tool to communicate with other &ecell
         users.  In fact, this manual uses &EM; to illustrate how a
         model is constructed in &ecell;</para>

    </sect3>

    </sect2>

    <sect2>
      <title>&EM; At A Glance</title>

      <para>Before getting in to the details of &EM; syntax, let's
      have a look at a tiny example. It's very simple.</para>

      <example>
	<title>A tiny &EM; example</title>
	<programlisting linenumbering="numbered">
Stepper ODE23Stepper( ODE_1 ) 
{ 
        # no property 
} 
 
System CompartmentSystem( / ) 
{ 
        StepperID       ODE_1;

        Variable Variable( SIZE )
        {
                Value   1e-18; 
        }
 
        Variable Variable( S ) 
        { 
                Value   10000; 
        } 
 
        Variable Variable( P ) 
        { 
                Value   0; 
        } 

        Process MassActionFluxProcess( E ) 
        { 
                Name  "A mass action from S to P."
                k     1.0; 

                VariableReferenceList [ S0 Variable:.:S -1 ] 
                                      [ P0 Variable:.:P 1 ]  ;
        } 
 
} 
</programlisting>
      </example>

      <para>In this example, the model has a &Stepper;, of which class
      name is <classname>ODE23Stepper</classname>, and has an ID
      ODE_1.  The model also has a root system ('/'), and the class
      name is <classname>CompartmentSystem</classname>.  The root
      sytem, has a StepperID property, and four &Entity; objects,
      &Variable;s SIZE, S and P, and a &Process; E.  The 'SIZE' is a
      special name of a &Variable;.  It determines the size of the
      compartment.  If the compartment is three-dimensional, it means
      the volume of the compartment in [L] (liter).  That value is
      used to calculate concentrations of other &Variable;s.  These
      &Entity; objects have their property values of several different
      types.  For example, 'StepperID' of the root system is a string
      without quotes (ODE_1). The initial value given to 'Value'
      property of the &Variable; S is an integer number 10000.  'Name'
      of the &Process; E is a quoted string "A mass action from S to
      P", and 'k' of it is a real number 1.0.  'VariableReferenceList'
      property of E is a list of two lists, which contain strings
      (such as 'S0'), and numbers (such as -1).</para>

    </sect2>


    <sect2>
      <title>General Syntax Of &EM;</title>

      <para>Basically &EM; is (and thus &EML; is) a list of just one
      type of directive: <emphasis>object instantiation</emphasis>.
      As we have seen, &ecell;'s simulation models have only two types 
      of 'objects'; &Stepper; and &Entity;.   After
      creating an object, property values of the object must be set.
      Therefore the object
      instantiation has two steps: (1) creating object
      and (2) setting properties.</para>

      <sect3>
	<title>A general form of an object instantiation statement</title>

      <para>The following is the general form of definition (instantiation) 
of an object in the simulation model:

<programlisting>
TYPE CLASSNAME ( ID )
"""INFO (<emphasis>optional</emphasis>)"""
{ 
        PROPERTY_NAME_1 PROPERTY_VALUE_1;
        PROPERTY_NAME_2 PROPERTY_VALUE_2;
        ...
        PROPERTY_NAME_n PROPERTY_VALUE_n;
} 
</programlisting>
where:
<itemizedlist>
	    <listitem>
	      <para>TYPE</para>
		<para>The type of the object, which is one of the followings:
      <itemizedlist>
	  <listitem>
	    <para>&Stepper;</para>
	  </listitem>
	  <listitem>
	    <para>&Variable;</para>
	  </listitem>
	  <listitem>
	    <para>&Process;</para>
	  </listitem>
	  <listitem>
	    <para>&System;</para>
	  </listitem>
	</itemizedlist>
</para>
	      </listitem>

	    <listitem>
	      <para>ID</para>
		<para>This is a <emphasis>StepperID</emphasis> if the
		object type is &Stepper;.  If it is &System;, put a
		&SystemPath; here.  Fill in an &EntityID; if it is
		&Variable; or &Process; (Not a &FullID; ; see the following
		sections).</para>
	      </listitem>

	    <listitem>
	      <para>CLASSNAME</para>
		<para>A classname of this object.  This class must be
a subclass of the baseclass defined by <emphasis>TYPE</emphasis>.
For example, if the <emphasis>TYPE</emphasis> is &Process;,
<emphasis>CLASSNAME</emphasis> must be a subclass of &Process;, such
as <classname>MassActionFluxProcess</classname>.</para>
	    </listitem>

	    <listitem>
	      <para>INFO</para>
		<para>This field is optional, and is not used in the
		simulation.  A quoted single-line ("string") or
		a multi-line string ("""multi-line string""") can be put
		here.</para>
	    </listitem>

	    <listitem>
	      <para>PROPERTY</para>
		<para>An object definition has zero or more property
		fields.</para> <para>A property field starts with an
		unquoted property name string, followed by a property
		value, and ends with a semi-colon (';').  For example,
		if the property name is 'Concentration' and the value
		is 10.0, it may look like:
		<informalexample>
		    <programlisting>Concentration 10.0;</programlisting></informalexample></para>

		<para>&Real;, &Int;, &StringType;, and List are
		allowed as property value types (See Object Properties
		above).</para> 

		<para>If the value is a List, outermost
		brackets are omitted.  For example, to put a list
		<programlisting>[ 10 "string" [ LIST ] ]</programlisting> 
                into a property slot 'Foo', write a
		line in a object definition like this:
<informalexample>
		    <programlisting>Foo 10 "string" [ LIST ];</programlisting>
		  </informalexample>
<note>
		    <title>Why the outermost brackets can be ommited?</title> 

		    <para>All property values are lists, even if it is
		    a scalar &Real; number.  Remember a number '1.0' is
		    interconvertible with a length-1 list '[ 1.0 ]'. 
                    Therefore the system can correctly interpret property
                    values without the brackets.
                    </para>

		    <para>In other words, if the property value is
		    bracketed, for example, the following property value
<programlisting>Foo [ 10 [ LIST ] ];</programlisting> 
                    is interpreted by the system as a length-1 List 
<programlisting>[ [ 10 [ LIST ] ] ]</programlisting> 
                    of which the first item is a list
<programlisting>[ 10 [ LIST ] ]</programlisting> 
                    This may or may not be what you intend to have.</para>
		  </note>
</para>

	    </listitem>

	  </itemizedlist>



</para>

      </sect3>

      <sect3>
	<title>Structure of the model</title>

	<para>Usually a model has one or more &Stepper; and &System;
	statements.  General structure of &EM; file may look like this:
<programlisting>
STEPPER_0
[ STEPPER_1 ]
...
[ STEPPER_n ]
{
}

SYSTEM_0 # the root system ( '/' )
[ SYSTEM_1 ]
...
[ SYSTEM_n ]
</programlisting>
</para>

	<para>A &System; statement can have zero or more
	&Variable; and &Process; statements.  Do not put a &System;
	statement inside &System;.

<programlisting>
System CompartmentSystem( / )
{

    Variable Variable( V0 ) {}
    Variable Variable( V1 ) {}
    # ...
    Variable Variable( Vn ) {}

    Process SomeProcess( P0 )  {}
    Process SomeProcess( P1 )  {}
    # ...
    Process OtherProcess( Pm ) {}
}
</programlisting>
</para>
      </sect3>

      <sect3>

	<title>System tree</title>

	<para>A System statement instantiates an instance of
         a sub-class of the &System; class.   A model has one or more
         &System; objects.</para>

	<para>A model must have at least the root sytem (/).

<programlisting>
System CompartmentSystem( / )
{
  ...
}
</programlisting>

         The class of the root system is always
         <classname>CompartmentSystem</classname>, no matter what
         class you specify.  This is because the simulator creates the
         root sytem when starts up, before loading a model file. That
         is, the statement does not actually create a &System; object,
         but just set property values.  Consequently the class name
         (in this case, it is also
         <classname>CompartmentSystem</classname>) is ignored.  This
         root system statement is always required, even if you have no
         property to set.
      </para>

	<para>If the model has more than one &System; objects, it must
         form a tree which starts from the root system (/).  For
         example, the following is <emphasis>not</emphasis> a valid &EM;.

<programlisting>
System CompartmentSystem( / )
{
}

System CompartmentSystem( /CELL0/MITOCHONDRION0 )
{
}
</programlisting>

         This is invalid because these two &System; objects,
         <literal>/</literal> and
         <literal>/CELL0/MITOCHONDRION0</literal> are not connected to
         each other, nor form a single tree.  Adding another &System;,
         /CELL0, makes it valid.

<programlisting>
System CompartmentSystem( / )
{
}

System CompartmentSystem( /CELL0 )
{
}

System CompartmentSystem( /CELL0/MITOCHONDRION0 )
{
}
</programlisting>

         Of course a &System; can have an arbitrary number of sub-systems.

<programlisting>
System CompartmentSystem( / )
{
}

System CompartmentSystem( /CELL1 ) {}
System CompartmentSystem( /CELL2 ) {}
System CompartmentSystem( /CELL3 ) {}
# ...
</programlisting>

</para>

	<note>
	  <title>Planned support for model composition</title>
	  <para>In future versions, the system will support a model
             composed of multiple model files (&EM;s or &EML;s).</para>
	</note>

      </sect3>

      <sect3>
	<title>Connecting &Stepper;s with &Entity; objects</title>

	<para>Any &Process; and &Variable; object in the model must be
         connected with a &Stepper; by specifying
         <property>StepperID</property> property.  If the
         <property>StepperID</property> of a &Process; is omitted, it
         defaults that of its supersystm (the &System; the &Process;
         belongs to).  <property>StepperID</property> of &System; cannot
         be omitted.</para>

	<para>In the following example, the root sytem is connected to
         a &Stepper; <literal>STEPPER0</literal>, and the &Process;
         <literal>P0</literal> and <literal>P1</literal> belongs to
         &Stepper;s <literal>STEPPER0</literal> and
         <literal>STEPPER1</literal>, respectively.

<programlisting>
System CompartmentSystem( / )
{
    StepperID     STEPPER0;

    Process AProcess( P0 )
    {
    }

    Process AProcess( P1 )
    {
        StepperID     STEPPER1;
    }
}
</programlisting>
</para>

	<para>Connections between &Stepper;s and &Variable;s are
	automatically determined by the system, and cannot be
	specified manually.  See the next section.</para>
      </sect3>


      <sect3>
	<title>Relating &Variable; objects with a &Process;</title>

	<para>A &Process; object changes values of &Variable;
         object(s) according to a certain procedure, such as the law
         of mass action.  What &Variable; objects the &Process; works
         on cannot be determined when it is programmed, but it must be
         specified by the modeler when the &Process; takes part in the
         simulation.  
         <property>VariableReferenceList</property> property of the
         &Process; relates some &Variable; objects with the &Process;.</para>

	<para><property>VariableReferenceList</property> is a list of
         <emphasis>&VariableReference;s</emphasis>.  A
         &VariableReference;, in turn, is usually a list of the
         following three or four elements:

<orderedlist>
	    <listitem>
	      <para>A reference name</para>

	      <para>This field gives a local name inside the &Process;
               to this &VariableReference;.  Some &Process; classes
               use this name to identify particular instances of
               &VariableReference;.</para>

	      <para>Currently, this reference name must be set for all
               &VariableReference;s, even if the &Process; does not
               use it at all.
               </para>

	      <para>Lexical rule for this field is the same
               as the &EntityID; ; leading alphabet or '_' with
               trailing alphabet, '_', and numeric characters.</para>
	    </listitem>

	    <listitem>
	      <para>A &FullID;</para>

	      <para>This &FullID; specifies a &Variable; that this
               &VariableReference; points to.</para>

	      <para>The &SystemPath; of the &FullID; can be relative.
	       Also, &EntityType; can be omitted.</para>

	    </listitem>

	    <listitem>
	      <para>A coefficient (<emphasis>optional</emphasis>)</para>

	      <para>An integer value that defines weight of the
               connection between the &Process; and the &Variable;
               that this &VariableReference; points to.  
              </para>

	      <para>If this value is non-zero integer, then this
               &VariableReference; is said to be a <emphasis>mutator
               &VariableReference;</emphasis>.  The &Process; can
               change the value of the &Variable; that this
               &VariableReference; points to.  If the value is zero,
               this &VariableReference; is not a mutator, and the &Process;
               should not change the value of the &Variable;.
               </para>

              <para>For example, if the &Process; represents a chemical
               reaction, this value is usually interpreted by the &Process;
               as a stoichiometric constant.  If the coefficient is -1,
               the value of the &Variable; is decreased by 1 in a single
               occurence or the forward reaction.</para>
	    </listitem>

	    <listitem>
	      <para>An <emphasis>isAccessor</emphasis> flag (<emphasis>optional</emphasis>)</para>

	      <para>This item is either 1 (true) or 0 (false).  If
               this <emphasis>isAccessor</emphasis> flag is false, it
               indicates that the behavior of &Process; is not
               affected by the &Variable; that this
               &VariableReference; points to.  That is, the &Process;
               never reads the value of the &Variable;. The &Process;
               may or may not change the &Variable; regardless of the value
               of this field.</para>

              <para><emphasis>The default of is 1 (true).</emphasis>
               This field is often omitted.</para>
	    </listitem>
	  </orderedlist>

	</para>

         <para>In &EM; syntax, it looks
         like this (the accessor flag is not used):
<programlisting>[ Reference_name FullID coefficient ]</programlisting>

</para>

      </sect3>



      <sect3>
	<title>Macros and preprocessing</title>

	<para>Before converting to &EML;,
         <command>ecell3-em2eml</command> command invokes the &empy;
         preprocessor to preprocess the given &EM; file.
        </para>

	<para>By using &empy;, you can embed any &Python;
	expressions and statements after '@' in an &EM; file.  Put
	a &Python; expression inside '@( <replaceable>python expression</replaceable> )', and the
	macro will be replated with an evaluation of the expression.
	If the expression is very simple, '()' can be ommited. Use '@{
	<replaceable>pytyon statements</replaceable> }' to embed &Python; statements.  For
	example, the following code:

<programlisting>@(AA='10')
@AA</programlisting> is expanded to:
	<programlisting>10</programlisting>

        Of course the statement can be multi-line.  This code 

<programlisting>
@{
  def f( str ):
      return str + ' is true.'
}

@f( 'Video Games Boost Visual Skills' )
</programlisting>

        is expanded to

<programlisting>Video Games Boost Visual Skills is true.</programlisting>
</para>

	<para>&empy; can also be used to include other files.  The
following line is replaced with the content of the file
<filename>foo.em</filename> immediately before the &EM; file is
converted to an &EML;: 

<programlisting>@include( 'foo.em' )</programlisting>
</para>

	<para>Use <option>-E</option> option of
	<command>ecell3-em2eml</command> command to see what happens
	in the preprocessing.  With this option, it outputs the result of the
	preprocessing to standard output and stops without creating an
	&EML; file.</para>

	<para>It has many more nice features.  See the appendix A
	for the full description of the &empy; program.</para>
      </sect3>

      <sect3>
	<title>Comments</title>

	<para>The comment character is a sharp '#'.  If a line contains
         a '#' outside a quoted-string, anything after the character
         is considered a comment, and not processed by the
         <command>ecell3-em2eml</command> command.</para>

	<para>This is processed differently from the &empy; comments
         (@#).  This comment character is processed by the &empy; as a
         usual character, and does not have an effect on the
         preprocessor.  That is, the part of the line after '#' is not
         ignored by &empy; preprocessor.   To comment out an &empy; macro, 
         the &empy; comment (@#) must be used.
         </para>
      </sect3>

    </sect2>

  </sect1>

  <!--
  <sect1>
    <title>Modeling Convensions</title>

    <sect2>
      <title>Units</title>

      <para><itemizedlist>
	  <listitem>
	    <para>Concentration</para>
	    <para>M, or Molar concentration.  </para>
	  </listitem>
	</itemizedlist>
</para>
    </sect2>

  </sect1>
  -->

  <sect1>
    <title>Modeling Examples</title>

    <para>Some basics on usage of ODE Steppers, NRStepper (Gillespie), DiscreteTimeStepper and SlaveStepper should come here.</para>


    <sect2>
      <title>A Trivial Reaction System</title>

      <para>At the very first, let us start with the simplest possible
      stable system of elementary reactions, which has two variables
      (in this case the numbers of molecules of molecular species) and
      a couple of elementary reaction processes.  Because elementary reactions
      are irreversible, at least two instances of the reactions are needed 
      for the system to be stable.  The reaction system looks like this:
<literallayout class="monospaced">
    -- P1 -->
S1            S2
   <-- P2 --
</literallayout>
      <literal>S1</literal> and <literal>S2</literal> are molecular
      species, and <literal>P1</literal> and <literal>P2</literal> are
      reaction processes.  Rate constants of both reactions are the
      same: 1.0 [1/s].  Initial numbers of molecules
      of <literal>S1</literal> and <literal>S2</literal> are 1000 and 0,
      respectively.  Because rate constants are the same, the system has
      a steady state at <literal>S1 == S2 == 500</literal>.</para>

    </sect2>

    <sect2>
      <title>Using Gillespie algorithm</title>

      <para>&app; comes with a set of classes for simulations using
       Gillespie's stochastic algorithm.</para>

      <sect3>
	<title>Specifying Gibson's Next Reaction method</title>

	<para><classname>NRStepper</classname> class implements Gibson's
         efficient variation of the Gillespie algorithm, or the Next
         Reaction (NR) method.</para>

	<para>To use the <classname>NRStepper</classname>
         in your simulation model, write like this in your &EM; file:

<programlisting>Stepper NRStepper( NR1 )
{
    # no property
}</programlisting>

       In this example, the <classname>NRStepper</classname> has the
       StepperID '<literal>NR1</literal>'. For now, no property
       needs to be specified for this object.</para>
      </sect3>


      <sect3>
	<title>Defining the compartment</title>

      <para>Next, define a compartment, and connect it to the &Stepper;
       <literal>NR1</literal>.   Because this model has only a single
       compartment, we use the root sytem (<literal>/</literal>).

<programlisting>System CompartmentSystem( / )
{
    StepperID       NR1;

    # ...
}
</programlisting>
</para>
      </sect3>

      <sect3>
	<title>Defining the variables</title>

	<para>Now define the main variables <literal>S1</literal> and
         <literal>S2</literal>.  Use '<property>Value</property> properties
         of the objects to set initial values.

<programlisting>System CompartmentSystem( / )
{
    # ...

    Variable Variable( S1 )
    {
        Value   1000;
    }
        
    Variable Variable( S2 )
    {
        Value   0;
    }
        
    # ...
}</programlisting>
</para>

      </sect3>

      <sect3>
	<title>Defining reaction processes</title>

	<para>Lastly, create reaction process instances
      <literal>P1</literal> and <literal>P2</literal>.
      <classname>GillespieProcess</classname> class works together
      with the <classname>NRStepper</classname> to simulate elementary
      reactions.</para>

	<para>Two different types of properties, <property>k</property>
      and <property>VariableReferenceList</property>, must be set for
      each of the <classname>GillespieProcess</classname> object.
      <property>k</property> is the rate constant parameter in [1/sec].
      <property>VariableReferenceList</property> property is </para>


      </sect3>


      <sect3>
	<title>Putting them together</title>
      <example>
	<title>The simplest Gillespie-Gibson model</title>
	<programlisting>Stepper NRStepper( NR1 )
{
    # no property
}

System CompartmentSystem( / )
{
    StepperID       NR1;

    Variable Variable( SIZE )    # the size (volume) of this compartment
    {
        Value   1e-18;
    }

    Variable Variable( S1 )
    {
        Value   1000;
    }
        
    Variable Variable( S2 )
    {
        Value   0;
    }
        
    Process GillespieProcess( P1 )              # the reaction S1 --> S2
    {
        VariableReferenceList   [ S Variable:.:S1 -1 ]
                                [ P Variable:.:S2 1 ];
        k       1.0;                            # the rate constant
    }

    Process GillespieProcess( P2 )              # the reaction S2 --> S1
    {
        VariableReferenceList   [ S Variable:.:S2 -1 ]
                                [ P Variable:.:S1 1 ];
        k       1.0;
    }
}
</programlisting>
      </example>
      </sect3>

    </sect2>

    <sect2>
      <title>Using Deterministic Differential Equations</title>
      <para></para>

      <example>
	<title>A simple mass-action model</title>
	<programlisting>
# A simple ODE mass-action model

Stepper ODE45Stepper( ODE1 )
{
	# no property
}

System CompartmentSystem( / )
{
	StepperID	ODE1;

	Variable Variable( S1 )
	{
		Value	1000;
	}
	
	Variable Variable( S2 )
	{
		Value	0;
	}
	
	Process MassActionFluxProcess( P1 )
	{
		VariableReferenceList	[ S0 Variable:.:S1 -1 ]
				        [ P0 Variable:.:S2 1 ];
		k	1.0;
	}

	Process MassActionProcess( P2 )
	{
		VariableReferenceList	[ S0 Variable:.:S2 -1 ]
 				        [ P0 Variable:.:S1 1 ];
		k	1.0;
	}
	
}
</programlisting>
      </example>


      <sect3>
	<title>Volume of the compartment</title>

	<para>Incidentally, in this particular trivial model,
         volume of the compartment does not affect the behavior of the
         model because all the reactions are first-order.   If you want
         to define the volume, create a &Variable;
         with an ID '<literal>SIZE</literal>'.  
         Because we model this compartment as a three-dimensional
         space, <literal>SIZE</literal> here means the volume
         of the compartment. 

<programlisting>System CompartmentSystem( / )
{
    # ...

    Variable Variable( SIZE )    # the size (volume) of this compartment
    {
        Value   1e-18;
    }

    # ...
}</programlisting>

         The unit of the volume is [L] (liter).  In this example, we set
         it to 1e-18.
        </para>
      
      </sect3>


    </sect2>



  </sect1>


  </chapter>


<!--
Local Variables:
mode: sgml
sgml-parent-document: ("ecell3-users-manual.xml" "book" "chapter")
End:
-->

