  <!-- ================ Writing em ================================ -->

  <chapter id="modeling"> 
  <title>Modeling with &ecell;</title> 

  <highlights>
    <para>By reading this chapter, you can get information about:</para>
    
    <simplelist>
      <member>How an &ecell;'s simulation model is organized.</member>
      <member>How to create a simulation model.</member>
      <member>How to write a model file in &EM; format.</member>
    </simplelist>
  </highlights>


  <sect1>
    <title>Simulation Model of &ecell;</title>

    <para>
    &ecell;'s simulation model is fully object-oriented.  That is, the
    simulation model is actually a set of <emphasis>objects</emphasis>
    connected each other.  The objects have
    <emphasis>properties</emphasis>, which determine characteristics
    of the objects (such as a reaction rate constant if the object
    represent a chemical reaction) and the relationships between
    objects.
    </para>

    <sect2>
      <title>Objects in the Model</title>

      <para>A simulation model of &app; consists of the following types of objects.
<itemizedlist>
	  <listitem>
	    <para>Usually more than one &Entity; object</para>
	  </listitem>
	  <listitem>
	    <para>One or more &Stepper; object(s)</para>
	  </listitem>
	</itemizedlist>
&Entity; objects define the structure of the simulation model and represented phenomena (such
as chemical reactions) in the model. &Stepper; objects
implement specific simulation algorithms.
</para>
  </sect2>


    <sect2>
      <title>&Entity; objects</title>

      <para>
The &Entity; class has three subclasses:
<itemizedlist>
	  <listitem>
	    <para>&Variable</para> <para>This class of objects represent state
	  variables.  A &Variable; object holds a scalar real-number
	  value.  A set of values of all &Variable; objects in a
	  simulation model defines the state of the model at a certain
	  point in time.</para>
	  </listitem>
	  <listitem>
	    <para>&Process</para> <para>This class of objects
	  represent phenomena in the simulation model that result in
	  changes in the values of one or more &Variable; objects.
	  The way of change of the &Variable; values can be either
	  discrete or continuous.</para>
	  </listitem>
	  <listitem>
	    <para>&System</para> <para>This class of objects define
	  overall structure of the model.  A &System; object can
	  contain sets of these three types of &Entity;, &Variable;,
	  &Process;, and &System; objects.  A &System; can contain
	  other &System;s, and can form a tree-like structure.  
	  </para>
	  </listitem>
	</itemizedlist>
</para>
      <sect3>
	<title>Root &System;</title>
	<para>When a simulator instance is newly instantiated, 
	a subclass object of &System;,
	a <classname>CompartmentSystem</classname>, is created. This
	&System; is called the <emphasis>root &System</emphasis>.
</para>
      </sect3>


    </sect2>

    <sect2>
      <title>&Stepper; objects</title>

      <para>A model must have one or more &Stepper; object(s).  Each
      &Process; and &System; object must be connected with a &Stepper;
      object in the same model.  In other words, &Stepper; objects in
      the model have non-overlapping sets of &Process; and &System;
      objects.</para>

      <para>&Stepper; is a class which implement a specific simulation
      algorithm.  If the model has more than one &Stepper; objects,
      the system conducts a multi-algorithm (or multi-stepper)
      simulation.  In addition to the lists of &Process; and &System;
      objects, a &Stepper; has a list of &Variable; objects that can
      be read or written by its &Process; objects.  It also has a time
      step interval as a positive real-number.  The system schedules
      &Stepper; objects according to the step intervals, and updates
      the current time. When called by the system, a &Stepper; object
      updates values of related &Variable; objects, calls zero, one or
      more &Process; objects connected with the &Stepper; in an order
      determined by its implementation of the algorithm, and
      determines the next time step interval.  See the following
      chapters for details of the simulation procedure.</para>

      <para></para>
    </sect2>




    <sect2>
      <title>Identifiers</title>

      <para>&app; uses several types of identifier strings to specify
      an object, such as the &Entity; and &Stepper;, in a simulation
      model.</para>

      <sect3>
	<title>&ID; (<emphasis>StepperID</emphasis>)</title>

	<para>Every &Entity; and &Stepper; object has an
	&ID;.  An &ID; is a character string of
	arbitrary length starting from an alphabet or '_' with
	succeeding alphabet, numeric, and '_' characters.  &app treats
	&ID;s in a case-sensitive way.</para>

	<para>If an &ID; is used to indicate a &Stepper; object, it is
	called a <emphasis>Stepper ID</emphasis>.  An &ID; points to
	an &Entity; object is refered to as <emphasis>Entity
	ID</emphasis>, or just <emphasis>ID</emphasis>.</para>

	<para>(need EBNF here)</para>

	<informalexample>
	  <para>Examples: _P3, ATP, GlucoKinase</para>
	</informalexample>

      </sect3>

      <sect3>
	<title>&SystemPath;</title>

	<para>The &SystemPath; identifies a &System; from the
	tree-like hierarchy of &System; objects in a simulation model.
	It has a form of &ID; strings joined by a character '/'
	(slash).  As a special case, the &SystemPath; of the root
	system is '/'. For instance, if there is a &System; 'A', and
	'A' has a subsystem 'B', a &SystemPath; '/A/B' specifies the
	&System; object 'B'.  It has three parts: (1) the root system
	('/'), (2) the &System; 'A' directly under the root system,
	and (3) the &System; 'B' just under 'A'.</para>

	<para>A &SystemPath can be relative.  That is, it can contain
	'.' and '..' to specify a current and a super (containing)
	&System;, respectively.  If a &SystemPath; is relative, it does
	not point at a &System; object unless a current &System; is
	given.</para>

	<informalexample>
	  <para>Examples: /A/B,  ../A, ., /CELL/ER1/../CYTOSOL</para>
	</informalexample>

      </sect3>

      <sect3>
	<title>&FullID;</title>

	<para>A &FullID; identifies a unique &Entity; object in a simulation
	model.  A &FullID; comprises three parts, (1) a
	<emphasis>Type</emphasis>, (2) a &SystemPath;, and (3) an
	&ID;, joined by a character ':' (colon).</para>

	<para>Type is one of the following class names:
<itemizedlist>
	    <listitem>
	      <para>&System;</para>
	    </listitem>
	    <listitem>
	      <para>&Process;</para>
	    </listitem>
	    <listitem>
	      <para>&Variable;</para>
	    </listitem>
	  </itemizedlist>
</para>

	<para>For example, the following &FullID; points to a &Process; object
of which &ID; is 'P', in the &System; 'CELL' directly under the root system.
<informalexample>
	    <programlisting>Process:/CELL:P</programlisting>
	  </informalexample>
</para>

      </sect3>

      <sect3>
	<title>&FullPN;</title>

	<para>&FullPN; specifies a unique
	<emphasis>property</emphasis> (see below) of an &Entity; object in the
	simulation model.  It has a form of a &FullID; and a name of a
	property joined by a character ':'.</para>

	<para>The following &FullPN; points to a 'Value' property of the &Variable; object 'Variable:/CELL:S'.
<informalexample>
	    <programlisting>Variable:/CELL:S:Value</programlisting>
	  </informalexample>
</para>
      </sect3>

    </sect2>



    <sect2>
      <title>Object Properties</title>

      <para>&Entity; and &Stepper; objects have
      <emphasis>properties</emphasis>.  Property is an attribute of a
      certain object associated with a name, which can be get from and
      set to an object.
      </para>

      <para>A value of a property has a <emphasis>type</emphasis>,
      which is one of the following types.

<itemizedlist>
	<title>Types of object properties</title>

	  <listitem>
	    <para>&Real; number</para> 
	    <para>(ex. 3.33e+10, 1.0)</para>
	  </listitem>
	  <listitem>
	    <para>&Int; number</para>
	    <para>(ex. 3, 100)</para>
	  </listitem>
	  <listitem>
	    <para>&StringType;</para>

	    <para>&StringType; has two forms: quoted and not quoted.
	    A quoted &StringType; can contain any
	    <acronym>ASCII</acronym> characters except the quotation
	    characters (' or ").  If a &StringType; is not quoted, it
	    can start with an alphabet character or '_', or '/', and
	    contain alphabets, numbers, '_', '/' and ':'.</para>

	    <para>Multi-line string support is currently under
	    development.</para>

	    <para>(ex. C10_A, "It can include spaces if double-quoted.", 'single-quote is available too, if you want to use "double-quotes" inside.')</para>
	  </listitem>

	  <listitem>
	    <para>List</para> <para>The list can contain &Real;,
	    &Int;, &StringType; values. This list can also contain
	    other lists, that is, the list can be nested.  A list must
	    be surrounded by brackets ('[' and ']'), and the elements
	    must be separated by space characters.  In some cases
	    outermost brackets are omitted (such as in &EM; files, see below).</para>
	    <para>(ex. [ A 10 [ 1.0 "a string" 1e+10 ] ] )</para>
	  </listitem>
	</itemizedlist>
</para>

      <sect3>
	<title>Dynamic type conversion of property values</title>

	<para>The system automatically convert the type of the
         property value if it is different from what the backend
         object (such as &Process; and &Variable;) expects to get.
         That is, the system does not necessary raise an error if the
         type of the given value differs from the type the backend
         object accepts.  The system always try to convert a type of
         the value given in a model file to a requested type by the
         backend object.  The conversion is done by the backend object,
         when it gets a property value.  See the
         following section.</para>

	<para>The conversion is done in the following manner.  
<itemizedlist>
	    <title>How property value type conversion is conducted</title>
	    <listitem>
	      <para>From a numeric value (&Real; or &Int;)</para>
	      <itemizedlist>
		<listitem>
		  <para>To a &StringType;</para> 

		  <para>The number is simply converted to a character
		  string. For example, a number 12.3 is converted to a
		  &StringType; '12.3'.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A numeric value can be converted to a length-1
		  list which has that number as the first item.  For
		  example, 12.3 is equivalent to '[ 12.3 ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a &StringType;</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric value (&Real; or &Int;)</para> 
		  
		  <para>The initial portion of the &StringType; is
                  converted to a numeric value.  The number can be
                  represented either in a decimal form or a
                  hexadecimal form.  Leading white space characters
                  are ignored.  'INF' and 'NAN' (case-insensitive) are
                  converted to an infinity and a NaN (not-a-number),
                  respectively.  If the initial portion of the
                  &StringType; cannot be converted to a numeric value,
                  it is interpreted as a zero (0.0 or 0).  This
                  conversion procedure is equivalent to C functions
                  <function>strtol</function> and
                  <function>strtod</function>, according to the
                  destined type.</para>
		</listitem>
		<listitem>
		  <para>To a list</para>

		  <para>A &StringType; can be converted to a length-1
		  list which has that &StringType; as the first item.  For
		  example, 'string' is equivalent to '[ 'string' ]'.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	    <listitem>
	      <para>From a list</para>
	      <itemizedlist>
		<listitem>
		  <para>To a numeric or a &StringType value</para> 

		  <para>It simply takes the first item of the list.
		  If necessary the taken value is further converted to
		  other types.</para>
		</listitem>
	      </itemizedlist>
	    </listitem>
	  </itemizedlist>


<note>
	    <title>Overflow or underflow when converting a property
	    value</title> 

	    <para>When converting from a &Real; number to an &Int;, or
	    from a &StringType; to a numeric value, overflow or
	    underflow can occur during the conversion.  In this case
	    an exception (TYPE??) is raised when the backend object
	    attempts the conversion.</para>
	  </note>

</para>


      </sect3>


    </sect2>


  </sect1>


  <sect1>
    <title>E-Cell Model (&EM;) File Basics</title>

    <sect2>
      <title>What is &EM;?</title>

      <para>
      In &app, the standard file format of model description and
      exchange is XML-based &EML; (E-Cell Model description Language).
      Although &EML; is an ideal means of integrating E-Cell with other
      software components such as GUI model editors and databases, it
      is very tedious for human users who want to write and edit their
      models directly by a text editor.  E-Cell Model (&EM;) is a file
      format with programming language-like syntax and a powerful
      embedded &empy; preprocessor, which is
      designed to be productive and intuitive especially when handled
      by the text editors and other text processing programs such as
      UNIX's <application>grep</application>,
      <application>diff</application> and
      <application>cat</application>.  Semantics of &EM; and &EML; files
      are almost completely equivalent to each other, and going
      between these two formats is meant to be possible with no loss
      of information (some exceptions are comments and directions to
      the preprocessor in &EM;).  The file suffix of &EM; files must be
      ".em".
    </para>

    <sect3>
      <title>Why and when use &EM;?</title>

      <para>Although <application>E-Cell Modeling
    Environment</application> will provide means of more sophisticated,
    scalable and intelligent model construction on the basis of &EML;,
    learning syntax and semantics of &EM; may help you get the idea of
    how object model inside &ecell is organized and how it is driven
    to conduct simulations.  Furthermore, owing to the nature of plain
    programming language-like syntax, &EM; can be used as a simple and
    intuitive tool to communicate with other &ecell users.  In fact,
    this manual uses &EM; to illustrate how a model is constructed in
    &ecell;</para>

    </sect3>

    </sect2>

    <sect2>
      <title>&EM; At a Glance</title>

      <para>Before getting in to the details of &EM; syntax, let's
      have a look at a tiny example. It's very simple.</para>

      <example>
	<title>A tiny &EM; example</title>
	<programlisting linenumbering="numbered">
Stepper ODE23Stepper( ODE_1 ) 
{ 
        # no property 
} 
 
System CompartmentSystem( / ) 
{ 
        StepperID       ODE_1;

        Variable Variable( SIZE )
        {
                Value   1e-18; 
        }
 
        Variable Variable( S ) 
        { 
                Value   10000; 
        } 
 
        Variable Variable( P ) 
        { 
                Value   0; 
        } 

        Process MassActionFluxProcess( E ) 
        { 
                Name  "A mass action from S to P."
                k     1.0; 

                VariableReferenceList [ S0 Variable:.:S -1 ] 
                                      [ P0 Variable:.:P 1 ]  ;
        } 
 
} 
</programlisting>
      </example>

      <para>In this example, the model has a &Stepper;, of which class
      name is <classname>ODE23Stepper</classname>, and has an ID
      ODE_1.  The model also has a root system ('/'), and the class
      name is <classname>CompartmentSystem</classname>.  The root
      sytem, has a StepperID property, and four &Entity; objects,
      &Variable;s SIZE, S and P, and a &Process; E.  The 'SIZE' is a
      special name of a &Variable;.  It determines the size of the
      compartment.  If the compartment is three-dimensional, it means
      the volume in [L] (liter).  That value is used to calculate
      concentrations of other &Variable;s.  These &Entity; objects
      have their property values of several different types.  For
      example, 'StepperID' of the root system is a string without
      quotes (ODE_1). The initial value given to 'Value' property of
      the &Variable; S is an integer number 10000.  'Name' of the
      &Process; E is a quoted string "A mass action from S to P", and
      'k' of it is a real number 1.0.  'VariableReferenceList'
      property of E is a list of two lists, which contain strings
      (such as 'S0'), and numbers (such as -1).</para>

    </sect2>


    <sect2>
      <title>General Syntax of &EM;</title>

      <para>Basically &EM; is (and thus &EML; is) a set of just one
      type of directive: <emphasis>object instantiation</emphasis>.
      And in &ecell;'s simulation model, the 'object' has, as we have
      seen, only two types, &Stepper; and &Entity;.   In addition, after
      creating an object, property values must be set.  Therefore the object
      instantiation has two steps: (1) creating object
      and (2) setting properties.</para>

      <sect3>
	<title>A general form of an object instantiation</title>

      <para>The following is the general form of definition (instantiation) 
of an object in the simulation model:

<programlisting>
TYPE CLASSNAME ( ID )
'''INFO (<emphasis>optional</emphasis>)'''
{ 
        PROPERTY_NAME_1 PROPERTY_VALUE_1;
        PROPERTY_NAME_2 PROPERTY_VALUE_2;
        ...
        PROPERTY_NAME_n PROPERTY_VALUE_n;
} 
</programlisting>
where:
<itemizedlist>
	    <listitem>
	      <para>TYPE</para>
		<para>An object type, which is one of the followings:
      <itemizedlist>
	  <listitem>
	    <para>&Stepper;</para>
	  </listitem>
	  <listitem>
	    <para>&Variable;</para>
	  </listitem>
	  <listitem>
	    <para>&Process;</para>
	  </listitem>
	  <listitem>
	    <para>&System;</para>
	  </listitem>
	</itemizedlist>
</para>
	      </listitem>

	    <listitem>
	      <para>ID</para>
		<para>This is a <emphasis>StepperID</emphasis> if the
		object type is &Stepper;.  If it is &System;, put a
		&SystemPath; here.  Fill in an &ID; if it is
		&Variable; or &Process; (Not a &FullID; ; see the following
		sections).</para>
	      </listitem>

	    <listitem>
	      <para>CLASSNAME</para>
		<para>A classname of this object.  This class must be
a subclass of the baseclass defined by the <emphasis>TYPE</emphasis>.
For example, if the <emphasis>TYPE</emphasis> is &Process;,
<emphasis>CLASSNAME</emphasis> must be a subclass of &Process;, such
as <classname>MassActionFluxProcess</classname>.</para>
	    </listitem>

	    <listitem>
	      <para>INFO</para>
		<para>This field is optional, and is not used for the
		simulation.  A quoted single-line ("string") or
		a multi-line string ('''multi-line string''') can be put
		here.</para>
	    </listitem>

	    <listitem>
	      <para>PROPERTY</para>
		<para>An object definition has zero or more property
		fields.</para> <para>A property field starts with an
		unquoted property name string, followed by a property
		value, and ends with a semi-colon (';').  For example,
		if the property name is 'Concentration' and the value
		is 10.0, it may look like:
		<informalexample>
		    <programlisting>Concentration 10.0;</programlisting></informalexample></para>

		<para>&Real;, &Int;, &StringType;, and List are
		allowed as property value types (See Object Properties
		above).</para> 

		<para>If the value is a List, outermost
		brackets are omitted.  For example, to put a list
		<programlisting>[ 10 "string" [ LIST ] ]</programlisting> 
                into a property slot 'Foo', write a
		line in a object definition like this:
<informalexample>
		    <programlisting>Foo 10 "string" [ LIST ];</programlisting>
		  </informalexample>
<note>
		    <title>Why the outermost brackets can be ommited?</title> 

		    <para>All property values are lists, even if it is
		    a scalar &Real; number.  Remember a number '1.0' is
		    interconvertible with a length-1 list '[ 1.0 ]'. 
                    Therefore the system can correctly interpret property
                    values without the brackets.
                    </para>

		    <para>In other words, if the property value is
		    bracketed, for example, the following property value
<programlisting>Foo [ 10 [ LIST ] ];</programlisting> 
                    is interpreted by the system as a length-1 List 
<programlisting>[ [ 10 [ LIST ] ] ]</programlisting> 
                    of which the first item is a list
<programlisting>[ 10 [ LIST ] ]</programlisting> 
                    This may or may not be what you intend to have.</para>
		  </note>
</para>

	    </listitem>

	  </itemizedlist>



</para>

      </sect3>

      <sect3>
	<title>Structure of an &EM; file</title>

	<para>Any number of &Stepper; and &System; statements can
	exist in the toplevel of an &EM; file.  Usually an &EM; file
	has one or more &Stepper; and &System; statements.  A &System;
        statement can have zero or more &Variable; and &Process; statements.
        There cannot be a &System; statement inside &System;.</para>

	<para>A model must at least have a root sytem (/).

<programlisting>
System CompartmentSystem( / )
{
  ...
}
</programlisting>

         The class of the root system is always
         <classname>CompartmentSystem</classname>, no matter what
         class you specify.  This is because the simulator creates the
         root sytem when starts up, before loading a model file. That
         is, the statement does not actually create a &System; object,
         but just set property values.  Consequently the class name
         (in this case, it is also
         <classname>CompartmentSystem</classname>) is ignored.  This
         root system statement is always required, even if you have no
         property to set.
      </para>

	<para>If the model has more than one &System; objects, it must
         form a tree which starts from the root system (/).  For
         example, the following is <emphasis>not</emphasis> a valid &EM;.

<programlisting>
System CompartmentSystem( / )
{
}

System CompartmentSystem( /LIVER/CELL1 )
{
}
</programlisting>

         This is invalid because these two &System; objects are not
         connected each other, nor form a single tree.
         Adding another &System;, /LIVER, makes it valid.

<programlisting>
System CompartmentSystem( / )
{
}

System CompartmentSystem( /LIVER )
{
}

System CompartmentSystem( /LIVER/CELL1 )
{
}
</programlisting>

         Of course a &System; can have an arbitrary number of sub-systems.

<programlisting>
System CompartmentSystem( / )
{
}

System CompartmentSystem( /LIVER )
{
}

System CompartmentSystem( /LIVER/CELL1 )
{
}

System CompartmentSystem( /LIVER/CELL2 )
{
}

System CompartmentSystem( /LIVER/CELL3 )
{
}
</programlisting>

</para>

	<note>
	  <title>Planned support for model composition</title>
	  <para>In future versions, the system will support a model
             composed of multiple model files (&EM;s or &EML;s).</para>
	</note>

      </sect3>

      <sect3>
	<title>Macros and preprocessing</title>

	<para>Before converting to an &EML; file by
	<command>ecell3-em2eml</command> command, an &EM; file is
        processed by &empy; preprocessor.</para>

	<para>By using &empy;, effectively you can embed any &Python;
	expressions and statements after '@' in an &EM; file.  Put
	a &Python; expression inside '@( <replaceable>python expression</replaceable> )', and the
	macro will be replated with an evaluation of the expression.
	If the expression is very simple, '()' can be ommited. Use '@{
	<replaceable>pytyon statements</replaceable> }' to embed &Python; statements.  For
	example, the following code:

<programlisting>@(AA='10')
@AA</programlisting> is expanded to:
	<programlisting>10</programlisting>

        Of course the statement can be multi-line.  This code 

<programlisting>
@{
  def f( str ):
      return str + ' is true.'
}

@f( 'Video Games Boost Visual Skills' )
</programlisting>

        is expanded to

<programlisting>Video Games Boost Visual Skills is true.</programlisting>
</para>

	<para>&empy; can also be used to include other files.  The
following line is replaced with the content of the file
<filename>foo.em</filename> immediately before the &EM; file is
converted to an &EML;: 

<programlisting>@include( 'foo.em' )</programlisting>
</para>

	<para>Use <option>-E</option> option of
	<command>ecell3-em2eml</command> command to see what happens
	in the preprocessing.  With this option, it outputs the result of the
	preprocessing to standard output and stops without creating an
	&EML; file.</para>

	<para>It has many more nice features.  See the appendix A
	for the full description of the &empy; program.</para>
      </sect3>

      <sect3>
	<title>Comments</title>

	<para>The comment character is sharp '#'.  If a line contains
         a '#' outside a quoted-string, anything after the character
         is considered a comment, and not processed by the
         <command>ecell3-em2eml</command> command.</para>

	<para>This is processed differently from the &empy; comments
         (@#).  This comment character is processed by the &empy; as a
         usual character, and does not have an effect on the
         preprocessor.  That is, the part of the line after '#' is not
         ignored by &empy; preprocessor.   To comment out an &empy; macro, 
         the &empy; comment (@#) must be used.
         </para>
      </sect3>

    </sect2>



  </sect1>


  <sect1>
    <title>Modeling Examples</title>

    <para>Some basics on usage of ODE Steppers, NRStepper (Gillespie), DiscreteTimeStepper and SlaveStepper should come here.</para>

  </sect1>


  </chapter>


<!--
Local Variables:
mode: sgml
sgml-parent-document: ("ecell3-users-manual.xml" "book" "chapter")
End:
-->

