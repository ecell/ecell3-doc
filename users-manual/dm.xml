  <!-- ============= Creating New Object Classes ========================= -->
  <chapter id="dm"> 
  <title>Creating New Object Classes</title> 

  <highlights>
    <para>
      This section describes how to define your own object classes for use
      in the simulation models.
      </para>

    <para>This section also explains &PropertySlot;.</para>
  </highlights>
  
  <sect1>
    <title>About Dynamic Modules</title>
    
    <para>Dynamic Module (DM) is a file containing an object class,
      especially C++ class, which can be loaded and instantiated by
      the application.  &app uses this mechanism to provide users a
      way of defining and adding new classes to appear in simulation
      models without recompiling the whole system.  Because the
      classes are defined in forms of native codes, this is the most
      efficient way of adding a new code or object class in terms of
      space and speed.</para>

    <para>In &app, subclasses of &Process;,
         &Variable;,
         &System; and
         &Stepper; classes can be dynamically
         loaded by the system.
      </para>

    <para>In addition to standard &DM;s distributed with &app,
      user-defined &DM; files can be created from C++ source code files
      ('.cpp' files) with the <command>ecell3-dmc</command> command.
      The compiled files usually take a form of shared library ('.so')
      files.
 </para>

  </sect1>

  <sect1>
    <title>Defining a new class</title>
    
    
    <para>A new object class can be defined by writing a C++ source
    code file with some special usage of C++ macros.</para>



    <para>Here is a boilarplate template of a &DM; file, with which you
    should feel familiar if you have a C++ experience. Replace
    <parameter>DMTYPE</parameter>, <parameter>CLASSNAME</parameter>, and
    <parameter>BASECLASS</parameter> according to your case.

    <example>
      <title>CLASSNAME.cpp; a boilarplate &DM; template.</title>
    <programlisting linenumbering="numbered">
#include &lt;libecs/libecs.hpp>
#include &lt;libecs/<parameter>BASECLASS</parameter>.hpp>

USE_LIBECS;

class <parameter>CLASSNAME</parameter>
  :
  public <parameter>BASECLASS</parameter>
{
  LIBECS_DM_OBJECT( <parameter>DMTYPE</parameter>, <parameter>CLASSNAME</parameter> );
public:
  <parameter>CLASSNAME</parameter>() {}// A constructor without an argument
  <parameter>~CLASSNAME</parameter>() {}// A destructor
};

DM_INIT( <parameter>DMTYPE</parameter>, <parameter>CLASSNAME</parameter> );
</programlisting>
    </example>
</para>


    <sect2>
      <title><parameter>DMTYPE</parameter>, <parameter>CLASSNAME</parameter> and <parameter>BASECLASS</parameter></title>

      <para>First of all you have to decide basic attributes of the
    class you are going to define; such as a &DM; type (&Process;, &Variable, &System;, or &Stepper), a class name, and a base class.</para>

      <itemizedlist>
	<listitem>
	<para><parameter>DMTYPE</parameter></para>

	<para><parameter>DMTYPE</parameter> is one of &DM; base classes
	defined in &app; &Process;,
	&Stepper;,
	&Variable;, and
	&System;.</para>
	</listitem>

	<listitem>
	<para><parameter>CLASSNAME</parameter></para>

	<para><parameter>CLASSNAME</parameter> is a name of the
	object class.</para>

	<para>This must be a valid C++ class name, and should end with the
	<parameter>DMTYPE</parameter> name. For example, if you are
	going to define a new &Process; class and
	want to name it <classname>Foo</classname>, the class name may
	look like <classname>FooProcess</classname>.</para>
	</listitem>

	<listitem>

	<para><parameter>BASECLASS</parameter></para>

	<para>The class your class inherits from.</para>

	<para>This may or may not be the same as the <parameter>DMTYPE
	</parameter>, depending on whether it is a direct
	descendant of the &DM; base class.</para>
	</listitem>

      </itemizedlist>

    </sect2>

    <sect2>
      <title>Filename</title>
      <para>
	The name of the source file must be the same as the <parameter>CLASSNAME</parameter>
	with a trailing '.cpp' suffix.  For example, if the <parameter>CLASSNAME</parameter>
	is <classname>FooProcess</classname>, the file name must be
	<filename>FooProcess.cpp</filename>.</para>
      
      <para>The source code can be divided into header and source
	files (such as <filename>FooProcess.hpp</filename> and
	<filename>FooProcess.cpp</filename>), but at least the
	<function>DM_INIT</function> macro must be placed in the source file
	of the class (<filename>FooProcess.cpp</filename>).</para>
      </sect2>


      <sect2>
	<title>Include Files</title> 

      <para>At least the <productname>libecs</productname> header file
	(<filename>libecs/libecs.hpp</filename>) and a header file of
	the base class (such as
	<filename>libecs/<parameter>BASECLASS</parameter>.hpp</filename>)
	must be included in the head of the file.</para>
      </sect2>

      <sect2>
	<title>DM Macros</title>

	<para>You may notice that it is using three special macros:
    <function>USE_LIBECS</function>, <function>
    LIBECS_DM_OBJECT</function>, and
    <function>DM_INIT</function>.</para>

	<para><function>USE_LIBECS</function> declares use of
         <productname>libecs</productname> library, which is the core
         library of &app, in this file after the line.</para>

	<para><function>LIBECS_DM_OBJECT( <parameter>DMTYPE</parameter>,
          <parameter>CLASSNAME</parameter> )</function> should be
          placed on the top of the class definition part (immediately
          after '{' of the class).  This macro declares that this is a
          &DM; class.  This macro makes it dynamically instantiable, and
          automatically defines
          <methodname>getClassName</methodname>() method.  Note that
          this macro specifies public: field inside, and thus anything
          comes after this is placed in public.  For clarity it is a
          good idea to always write public: explicitly after this
          macro.  <programlisting> LIBECS_DM_OBJECT( DMTYPE, CLASSNAME )
          public:</programlisting>
</para>

	<para><function>DM_INIT( <parameter>DMTYPE</parameter>,
	<parameter>CLASSNAME</parameter> )</function> exports the
	class <parameter>CLASSNAME</parameter> as a &DM; class of type
	<parameter>DMTYPE</parameter>.  This must come after the
	definition (not just a declaration) of the class to be
	exported with
	a <function>LIBECS_DM_OBJECT</function> call.</para>

      </sect2>

      <sect2>
	<title>Constructor And Destructor</title> 

	<para>DM objects are always instantiated by calling the
	constructor with no argument.  The destructor is defined virtual
        in the base class.</para>
      </sect2>


    <sect2>
      <title>Types And Declarations</title>

      <sect3>
	<title>Basic types</title>

	<para>The following four basic types are available to be used in
      your code if you included <filename>libecs/libecs.hpp</filename>
      header file and called the <function>USE_LIBECS</function>
      macro.

      <itemizedlist>
	    <listitem>
	      <para><type>Real</type></para>

	      <para>A real number.  Usually implemented as a double
	      precision floating point number.  It is a 64-bit float
	      on a Linux/IA32/gcc platform.</para>
	    </listitem>
	    <listitem>
	      <para><type>Int</type></para>

	      <para>A signed integer number.   This is a 64-bit <type>long int</type> on Linux/IA32/gcc.</para>
	    </listitem>
	    <listitem>
	      <para><type>UnsignedInt</type></para>

	      <para>An unsigned integer number. This is a 64-bit <type>unsigned long int</type> on Linux/IA32/gcc. </para>
	    </listitem>
	    <listitem>
	      <para>&String;</para>

	      <para>A string equivalent to
	    <classname>std::string</classname> class of the C++ standard
	    library.</para>
	    </listitem>
	    <listitem>
	      <para>&Polymorph;</para>

	      <para>&Polymorph; is a sort of
              universal type (actually a class) which can *become* and
              *be made from* any of <type>Real</type>, <type>Int</type>,
              <type>String</type>, and <type>PolymorphVector</type>,
              which is a mixed list of these three types of
              objects. See the next section for details.</para>
	    </listitem>
	  </itemizedlist>
</para>

	<para>These types are recommended to be used over other C++
      standard types such as <type>double</type>, <type>int</type> and
      <type>char*</type>.</para>

      </sect3>

      <sect3>
	<title>Pointer and reference types</title>

      <para>For each types, the following typedefs are available.
<itemizedlist>
	  <listitem>
	    <para><type>TYPEPtr</type></para>
	    <para>Pointer type. (== <type>TYPE*</type>)</para>
	  </listitem>

	  <listitem>
	    <para><type>TYPECptr</type></para>
	    <para>Const pointer type. (== <type>const TYPE*</type>)</para>
	  </listitem>

	  <listitem>
	    <para><type>TYPERef</type></para>
	    <para>Reference type. (== <type>TYPE&</type>)</para>
	  </listitem>

	  <listitem>
	    <para><type>TYPECref</type></para>
	    <para>Const reference type. (== <type>const TYPE&</type>)</para>
	  </listitem>
	</itemizedlist>

       For example, <type>RealCref</type> is equivalent to write
       <type>const Real&</type>.  Using these typedefs are recommended.</para>

       <para>
       To declare a new type, use <function>DECLARE_TYPE</function>
       macro.  For example, 
<programlisting>DECLARE_TYPE( double, Real );</programlisting> 

       is called inside the system so that
       <type>RealCref</type> can be used as <type>const
       double&</type>.</para>

      <para>Similary, DECLARE_CLASS can be used to enable the typedefs
      for a class. Example: 

<programlisting>DECLARE_CLASS( Process );</programlisting> 

      enables <type>ProcessCref</type>
      <type>ProcessPtr</type> etc..  Most classes defined in
      <productname>libecs</productname> have these typedefs.</para>

      </sect3>


      <sect3>
	<title>Limits and other attributes of types</title>

	<para>To get limits and precisions of these numeric
       types, use <classname>std::numeric_limits<></classname>
       template class in the C++ standard library.  For instance, to
       get a maximum value that can be represented by the
       <type>Real</type> type, use the template class like this:

<programlisting>
#include &lt;limits>
numeric_limits&lt;Real>::max();
</programlisting>

See the C++ standard library reference manual for more.</para>

      </sect3>


    </sect2>

      <sect2>
	<title>&Polymorph; class</title>

	<para>A &Polymorph; object can be
	constructed from and converted to any of <type>Real</type>,
	<type>Int</type>, <type>String</type>, types and
	&PolymorphVector; class.</para>
	
      <sect3>
	<title>Construct a &Polymorph;</title>

	<para>To construct a &Polymorph; object, simply call a constructor with a value:

<programlisting>
Polymorph anIntPolymorph( 1 );
Polymorph aRealPolymorph( 3.1 );
Polymorph aStringPolymorph( "2.13e2" );
</programlisting>

A &Polymorph; object can be constructed (or
copied) from a &Polymorph;:
<programlisting>
Polymorph aRealPolymorph2( aRealPolymorph );
</programlisting></para>
      </sect3>

      <sect3>
	<title>Getting a value of a &Polymorph;</title>

	<para>The value of the &Polymorph;
	objects can be retrieved in any type by using <methodname>as&lt;></methodname>() template method.
<programlisting>
anIntPolymorph.as&lt;Real>();    // == 1.0
aRealPolymorph.as&lt;String>(); // == "3.1"
aStringPolymorph.as&lt;Int>();  // == 213
</programlisting>

<note>
	    <para>If an overflow occurs when converting a very big <type>Real</type> value to <type>Int</type>, a <exceptionname>ValueError</exceptionname> exception?? is thrown.  (NOT IMPLEMENTED YET)</para>
	  </note>


</para>

      </sect3>

      <sect3>
	<title>Examining and changing the type of &Polymorph;</title>

	<para><methodname>getType</methodname>(), <methodname>changeType</methodname>()</para>

      </sect3>


      <sect3>
	<title>&PolymorphVector;</title>

	<para>&PolymorphVector; is a list of
	&Polymorph; objects.</para>
      </sect3>

      </sect2>


      <sect2>
	<title>Other C++ statements</title>

	<para>The only limitation is the <function>DM_INIT</function>
	macro, which exports a class as a &DM; class, can appear only
	once in a compilation unit which forms a single shared library
	file.</para>

	<para>Except for that, there is no limitation as far as the C++
	compiler understands it.  There can be any C++ statements
	inside and outside of the class definition including; other
	class definitions, nested classes, typedefs, static functions,
	namespaces, and even template<>.</para>

	<para>Be careful, however, about namespace corruptions. You
          may want to use private C++ namespaces and static functiont
          when a class or a function declared outside the &DM; class is
          needed.</para>
      </sect2>

    </sect1>

  <sect1>
    <title>PropertySlot</title>

    <sect2>
      <title>What is &PropertySlot;</title>

      <para>&PropertySlot; is a pair of methods to access (get) and
      mutate (set) an <emphasis>object property</emphasis>, associated
      with the name of the property.  Values of the object property
      can either be stored in a member variable of the object, or
      dynamically created when the methods are called.</para>

      <para>All of the four &DM; base classes,
         &Process;,
         &Variable;,
         &System; and
         &Stepper; can have a set of &PropertySlot;s, or object
         <emphasis>properties</emphasis>.  In other words, these classes 
         inherit &PropertyInterface; common base class.</para>

      <sect3>
	<title>What is 
	&PropertySlot; for?</title>

	<para>&PropertySlot;s can be used from
	model files (such as EM files) as a means of giving parameter
	values to each objects in the simulation model (such as
	&Entity; and
	&Stepper; objects). It can also be ways
	of dynamic communications between objects during the simulation.</para>
      </sect3>

      <sect3>
	<title>Type of &PropertySlot;</title>

	<para>A type of a &PropertySlot; is
	any one of these four types:

<itemizedlist>
	    <listitem>
	      <para><type>Real</type></para>
	    </listitem>
	    <listitem>
	      <para><type>Int</type></para>
	    </listitem>
	    <listitem>
	      <para><type>String</type></para>
	    </listitem>
	    <listitem>
	      <para><type>Polymorph</type></para>
	    </listitem>
	  </itemizedlist>
</para>

      </sect3>
    </sect2>

    <sect2>
      <title>How to define a &PropertySlot;</title>

      <para>To define a &PropertySlot; on an
      object class, you have to:
<orderedlist>
	  <listitem>
	    <para>Define set and/or get method(s).</para>
	  </listitem>

	  <listitem>
	    <para>If necessary, define a member variable to store
	    the property value.</para>
	  </listitem>

	  <listitem>
	    <para>Register the method(s) as a &PropertySlot;.</para>
	  </listitem>
	</orderedlist>
</para>

      <sect3>
	<title>Set method and get method</title>

	<para>A &PropertySlot; is a
      pair of object methods, <emphasis>set method</emphasis> and
      <emphasis>get method</emphasis>, associated with a property
      name.  Either one of the methods can be ommited.  If there is a
      set method defined for a &PropertySlot;,
      the &PropertySlot; is said to be
      <emphasis>setable</emphasis>.  If there is a get method, it is
      <emphasis>getable.</emphasis></para>

	<para>A set method must have the following signature to be
	recognized by the system.

	<programlisting>void CLASS::* ( const T& )</programlisting>

	And a get method must look like this: 

<programlisting>const T	CLASS::* ( void ) const</programlisting> 

        where <type>T</type>
	is a property type and
	<type>CLASS</type> is the object class that the
	&PropertySlot; belongs to.
</para>

	<para>Don't worry, you don't need to memorize these prototypes.
The following four macoros can be used to declare and define set/get methods
of a specific type and a property name.

<itemizedlist>
	    <listitem>
	      <para><function>SET_METHOD( <parameter>TYPE</parameter>, <parameter>NAME</parameter> )</function>
</para>

	      <itemizedlist>
		<listitem>
		  <para><emphasis>Expansion:</emphasis>
<programlisting>void set<parameter>NAME</parameter>( const <parameter>TYPE</parameter>& value )</programlisting></para>
		</listitem>

		<listitem>
		  <para><emphasis>Usage:</emphasis> <function>SET_METHOD</function> macro is
	      used to declare or define a property set method, of which the property type is <parameter>TYPE</parameter> and the property name is <parameter>NAME</parameter>, in a
	      class scope (class definition).  The given property
	      value is available as the <varname>value</varname>
	      argument variable.</para>
		</listitem>

		<listitem><para><emphasis>Example:</emphasis></para>
		  <informalexample>
		    <para>This code:
<programlisting>class HogeProcess
{
  SET_METHOD( Real, Flux )
  {
    theFlux = value;
  }

  Real theFlux;
};</programlisting>

is expanded to the following valid C++ program.

<programlisting>class HogeProcess
{
  void setFlux( const Real& value )
  {
    theFlux = value;
  }

  Real theFlux;
};
</programlisting>

In this example, the given property value is stored in a member variable
<varname>theFlux</varname>.
</para>
</informalexample>


		</listitem>

	      </itemizedlist>

	    </listitem>
	    <listitem>
	      <para><function>GET_METHOD( <parameter>TYPE</parameter>, <parameter>NAME</parameter> )</function>
</para>

	      <itemizedlist>
		<listitem>
		  <para><emphasis>Expansion:</emphasis>
<programlisting>const <parameter>TYPE</parameter> get<parameter>NAME</parameter>() const</programlisting></para>
		</listitem>

		<listitem>
		  <para><emphasis>Usage:</emphasis>
	      <function>GET_METHOD</function> macro is used to declare
	      or define a property get method, of which the property
	      type is <parameter>TYPE</parameter> and the property
	      name is <parameter>NAME</parameter>, in a class scope
	      (class definition).  Definition of the method must
	      return the value of the property as a
	      <parameter>TYPE</parameter> object.</para>
		</listitem>

		<listitem><para><emphasis>Example:</emphasis></para>
		  <informalexample>
		    <para>This code:
<programlisting>class HogeProcess
{
  GET_METHOD( Real, Flux )
  {
    return theFlux;
  }

  Real theFlux;
};</programlisting>

is expanded to the following valid C++ program.

<programlisting>class HogeProcess
{
  const Real getFlux() const
  {
    return theFlux;
  }

  Real theFlux;
};
</programlisting>
</para>
</informalexample>
		</listitem>
	      </itemizedlist>

	    </listitem>

	    <listitem>
	      <para><function>SET_METHOD_DEF( <parameter>TYPE</parameter>, <parameter>NAME</parameter>, <parameter>CLASSNAME</parameter> )</function>
</para>

	      <itemizedlist>
		<listitem>
		  <para><emphasis>Expansion:</emphasis>
<programlisting>void <parameter>CLASSNAME</parameter>::set<parameter>NAME</parameter>( const <parameter>TYPE</parameter>& value )</programlisting></para>
		</listitem>
		
		<listitem>
		  <para><emphasis>Usage:</emphasis>
		  <function>SET_METHOD_DEF</function> macro is used to
		  define a property set method outside class
		  scope.</para>
		</listitem>

		<listitem>
<para><emphasis>Example:</emphasis></para>
		  <informalexample>
		    <para><function>SET_METHOD_DEF</function> macro is usually
used in conjunction with <function>SET_METHOD</function> macro.  For instance,
the following code declares a property get method in the class scope by using 
<function>SET_METHOD</function>, and defines the procedure of the method 
after the class definition with <function>SET_METHOD_DEF</function>. 
In this example, the method is virtual.

<programlisting>class HogeProcess
{
  virtual SET_METHOD( Real, Flux );

  Real theFlux;
};

SET_METHOD_DEF( Real, Flux, HogeProcess )
{
  return theFlux;  
}
</programlisting>
</para>
</informalexample>
		</listitem>

	      </itemizedlist>
	      </listitem>
	      
	      <listitem>
	      <para><function>GET_METHOD_DEF( <parameter>TYPE</parameter>, <parameter>NAME</parameter>, <parameter>CLASSNAME</parameter> )</function>
</para>

	      <itemizedlist>
		<listitem>
		  <para><emphasis>Expansion:</emphasis>
<programlisting>const <parameter>TYPE</parameter> <parameter>CLASSNAME</parameter>::get<parameter>NAME</parameter>() const</programlisting></para>
		</listitem>

		<listitem>
		  <para><emphasis>Usage:</emphasis>
		  <function>GET_METHOD_DEF</function> macro is used to
		  define a property get method outside class
		  scope.</para>
		</listitem>

		<listitem>
		  <para><emphasis>Example:</emphasis> See the example
		  of <function>SET_METHOD_DEF</function> above.</para>
		</listitem>
	      </itemizedlist>

	    </listitem>
	  </itemizedlist>

</para>
      </sect3>



      <sect3>
	<title>Registering &PropertySlot;s</title>
	
	<para>To create a &PropertySlot; with both set and get methods, use
	<function>CREATE_PROPERTYSLOT_SET_GET</function> macro in the
	constructor or a method called when the object is constructed:

        <programlisting>CREATE_PROPERTYSLOT_SET_GET( <parameter>NAME</parameter>, <parameter>TYPE</parameter>, <parameter>CLASSNAME</parameter> )</programlisting> 

         where <parameter>NAME</parameter> is the name, and
         <parameter>TYPE</parameter> is the type of the property, and
         <parameter>CLASSNAME</parameter> is the name of the object
         class on which the &PropertySlot; is being defined.  This
         macro registers methods of the object class of which names
         are set<parameter>NAME</parameter>() and
         get<parameter>NAME</parameter> as set method and get method,
         respectively.  Signatures of the methods must match with the
         prototypes defined in the previous section.</para>

	<para>If the &PropertySlot; has either set or get method, use 

        <programlisting>CREATE_PROPERTYSLOT_SET( <parameter>NAME</parameter>, <parameter>TYPE</parameter>, <parameter>CLASSNAME</parameter> )</programlisting> 

         if only the set method is to be defined, or 

        <programlisting>CREATE_PROPERTYSLOT_GET( <parameter>NAME</parameter>, <parameter>TYPE</parameter>, <parameter>CLASSNAME</parameter> )</programlisting> 

         if the &PropertySlot; is getable and not setable.
</para>

	<para>For example, this line of code

<programlisting>CREATE_PROPERTYSLOT_SET_GET( Flux, Real, HogeProcess );</programlisting>
         registers these methods

<programlisting>void HogeProcess::setFlux( const Real& );</programlisting>

and       

<programlisting>const Real HogeProcess::getFlux() const;</programlisting>

         as the set and get methods of '<property>Flux</property>'
         property of the class <classname>HogeProcess</classname>,
         respectively.
</para>

	<para>If the name of either get or set method is different
         from the default format (set<parameter>NAME</parameter>() or
         get<parameter>NAME</parameter>()), then use

<programlisting>CREATE_PROPERTYSLOT( <parameter>NAME</parameter>, <parameter>TYPE</parameter>, <parameter>SET_METHOD</parameter>, <parameter>GET_METHOD</parameter>)</programlisting>

         macro with explicitly specifying the pointers to the methods.
         For example, the following use of the macro registers
         <methodname>setFlux2</methodname>() and
         <methodname>anotherGetMethod</methodname>() methods of
         <property>Flux</property> property of the class
         <classname>HogeProcess</classname>:

<programlisting>
CREATE_PROPERTYSLOT( Flux, Real, &amp;HogeProcess::setFlux2,
                     &amp;HogeProcess::anotherGetMethod );</programlisting>
</para>


	<para>
If more than one &PropertySlot;s with the same name are created
on an object, the last is taken.</para>
      </sect3>


      <sect3>
	<title>The simplest way to define property methods</title>

	<para>If the property is both setable and getable, and is simply
         stored in a member variable, use the following macro.

	<programlisting>SIMPLE_SET_GET_METHOD( <parameter>NAME</parameter>, <parameter>TYPE</parameter> )</programlisting>

        This assumes there is a variable with the same name as the 
        property name (<parameter>NAME</parameter>), and expands to a
        code that is equivalent to:

<programlisting>SET_METHOD( <parameter>NAME</parameter>, <parameter>TYPE</parameter> )
{
  <parameter>NAME</parameter> = value;
}

GET_METHOD( <parameter>NAME</parameter>, <parameter>TYPE</parameter> )
{
  return <parameter>NAME</parameter>;
}
</programlisting>

</para>

      </sect3>

      <sect3>
	<title>Virtual functions and &PropertySlot;s</title>

	<para>Virtual functions does not work for &PropertySlot;.  The
	functions given as set / get methods of &PropertySlot;s work
	and are treated as non-virtual functions.  If you have two
	&DM; classes A and B, and B inherits A with a virtual function
	overridden, you may want to define &PropertySlot;s of the same
	name for both classes, and you get virtually the same result
	as the virtual function.</para>

	<note>
	  <para>This can be easily understood if you remember
            &PropertySlot;s are defined in
            constructors. In C++ objects are constructed in a
            bottom-up fashion, or from base to derived classes. Thus
            the constructors are called in the same order, and always
            the latest ones are taken.</para>
	  </note>

      </sect3>

    </sect2>


    <sect2>
      <title>Using &PropertySlot; From Model Files</title> 

      <para>See the modeling chapter of this manual.</para>

      <para>For example, the following &EM; file invokes the set
method (<methodname>getFlux</methodname>()) of a
<classname>HogeProcess</classname> &Process; with a new property value
<parameter>10.0</parameter>, when this model is loaded by the
simulation with <methodname>loadModel</methodname>() method.

<programlisting>
System CompartmentSystem( / )
{
        Process HogeProcess( P )
        {
                Flux 10.0;
        }
}
</programlisting>
</para>

      <para>Similarly, get methods are called when the state of the
model is saved to a file during the simulation by
<methodname>saveModel</methodname>() method of the simulator.</para>

      <note>
	<title>Methods used to load/save simulation model</title>

	<para>In future versions it may become possible to specify
special load and save methods, in addition to usual set/get
methods. This functionality is useful if (1) the usual set/get methods
involve some special procedures that are meaningful only during the
simulation, or (2) the property is setable/getable while it does not need
to be loaded/saved from/to the model files.</para>
      </note>


    </sect2>

    <sect2>
      <title>Using &PropertySlot;s In Simulation</title>
	
      <para>(1) Static direct access (using native C++ method)
bypassing the &PropertySlot;, (2) dynamically-bound access via a
&PropertySlot; object, (3) dynamically-bound access via
&PropertyInterface;.</para>
    </sect2>

  </sect1>


    <sect1>
      <title>Defining a new Process class</title>


      <para>To define a new &Process; class, 
      at least <methodname>process()</methodname> and 
      <methodname>initialize()</methodname> methods must be defined.
      </para>


      <para>VariableReference, VariableReferenceVector, FluxProcess</para>

    <example>
      <title>SimpleFluxProcess.cpp</title>
    <programlisting linenumbering="numbered">
#include "libecs.hpp"
#include "FluxProcess.hpp"
#include "PropertySlotMaker.hpp"

USE_LIBECS;

class SimpleFluxProcess
  :
  public FluxProcess
{

  LIBECS_DM_OBJECT( Process, SimpleFluxProcess );

 public:

  SimpleFluxProcess()
    {
      CREATE_PROPERTYSLOT_SET_GET( Real, k, SimpleFluxProcess );
    }

  SIMPLE_SET_GET_METHOD( Real, k );

  virtual void initialize()
    {
      FluxProcess::initialize();
      S0 = getVariableReference( "S0" );
    }

  virtual void process()
    {
      setFlux( k * S0.getConcentration() );
    }

 protected:

  Real k;
  VariableReference S0;
};

DM_INIT( Process, SimpleFluxProcess );
</programlisting>
    </example>

      
    </sect1>

    <sect1>
      <title>Defining a new Stepper class</title>
    <para></para>
    </sect1>


    <sect1>
      <title>Defining a new Variable class</title>
    <para></para>
    </sect1>

    <sect1>
      <title>Defining a new System class</title>
    <para></para>
    </sect1>

  </chapter>



<!--
Local Variables:
mode: sgml
sgml-parent-document: ("ecell3-users-manual.xml" "book" "chapter")
End:
-->
