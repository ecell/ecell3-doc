  <!-- ============= Creating New Object Classes ========================= -->
  <chapter id="create-new-class"> 
  <title>Creating New Object Classes</title> 

  <highlights>
    <para>
      This section describes how to define your own object classes for use
      in the simulation models.
      </para>
  </highlights>
  
  <sect1>
    <title>About Dynamic Modules</title>
    
    <para>Dynamic Module (DM) is a file containing an object class,
      especially C++ class, which can be loaded and instantiated by
      the application.  &app uses this mechanism to provide users a
      way of defining and adding new classes to appear in simulation
      models without recompiling the whole system.  Because the
      classes are defined in forms of native codes, this is the most
      efficient way of adding a new code or object class in terms of
      space and speed.</para>

    <para>In &app, subclasses of <classname>Process</classname>,
         <classname>Variable</classname>,
         <classname>System</classname> and
         <classname>Stepper</classname> classes can be dynamically
         loaded by the system.
      </para>

    <para>In addition to standard DMs distributed with &app,
      user-defined DM files can be created from C++ source code files
      ('.cpp' files) with the <command>ecell3-dmc</command> command.
      The compiled files usually take a form of shared library ('.so')
      files.
 </para>

  </sect1>

  <sect1>
    <title>Defining a new class</title>
    
    
    <para>A new object class can be defined by writing a C++ source
    code file with some special usage of C++ macros.</para>


    <sect2>
      <title>Basic attributes</title>

    <para>First of all you have to decide basic attributes of the
    class you are going to define; such as class name, base class,
    and what types of properties it have.  At least you must have
    the following items filled in before starting to write a DM:</para>
    <itemizedlist>

      <title>List of common attributes of a DM class.</title>


      <listitem>
	<para><parameter>TYPE</parameter></para> 

	<para>One of DM base classes defined in the system;
	<classname>Process</classname>,
	<classname>Stepper</classname>,
	<classname>Variable</classname>, and
	<classname>System</classname>.</para>
      </listitem>

      <listitem>
	  <para><parameter>CLASSNAME</parameter></para> 

	<para>The name of the object class.</para> 

	<para>This must be a valid C++ class name, and end with the
	<parameter>TYPE</parameter> name. For example, if you are
	going to define a new <classname>Process</classname> class and
	want to name it <classname>Foo</classname>, the class name may
	look like <classname>FooProcess</classname>.</para>
      </listitem>

      <listitem>
	  <para><parameter>BASECLASS</parameter></para>

	<para>The class your class inherits from.</para>

	<para>This may or may not be the same as the <parameter>TYPE
	</parameter>, depending on whether it is a direct
	descendant of the DM base class.</para>

      </listitem>


      <listitem>
	<para>Properties</para>

	<para>A list of properties of this class.</para>

	<para>In addition to usual methods and member variables of a
	C++ class, E-Cell's DM classes can have
	<classname>PropertySlot</classname>s.  A <classname>PropertySlot</classname> is an interface 
</para>


      </listitem>

</itemizedlist>

    </sect2>


    <sect2>
      <title>Writing a source file</title>

    <para>Here is a minimum template of a DM file, with which you
    should feel familiar if you have a C++ experience. Replace
    <parameter>TYPE</parameter>, <parameter>CLASSNAME</parameter>, and
    <parameter>BASECLASS</parameter> according to your case.

    <example>
      <title>CLASSNAME.cpp; a minimum DM source code template.</title>
    <programlisting linenumbering="numbered">
#include &lt;libecs/libecs.hpp>
#include &lt;libecs/<parameter>BASECLASS</parameter>.hpp>

USE_LIBECS;

class <parameter>CLASSNAME</parameter>
  :
  public <parameter>BASECLASS</parameter>
{
  LIBECS_DM_OBJECT( <parameter>TYPE</parameter>, <parameter>CLASSNAME</parameter> );
public:
  <parameter>CLASSNAME</parameter>() {}// A constructor without an argument
  <parameter>~CLASSNAME</parameter>() {}// A destructor
};

DM_INIT( <parameter>TYPE</parameter>, <parameter>CLASSNAME</parameter> );
</programlisting>
    </example>
</para>

      <sect3>
	<title>Filename</title>
	<para>
	The name of the source file must be the same as the <parameter>CLASSNAME</parameter>
	with a trailing '.cpp' suffix.  For example, if the <parameter>CLASSNAME</parameter>
	is <classname>FooProcess</classname>, the file name must be
	<filename>FooProcess.cpp</filename>.</para>

	<para>The source code can be divided into header and source
	files (such as <filename>FooProcess.hpp</filename> and
	<filename>FooProcess.cpp</filename>), but at least the
	<function>DM_INIT</function> macro must be placed in the source file
	of the class (<filename>FooProcess.cpp</filename>).</para>
      </sect3>


      <sect3>
	<title>Include files</title> <para>At least the
	<productname>libecs</productname> header file
	(<filename>libecs/libecs.hpp</filename>) and a header file of
	the base class
	(<filename>libecs/<parameter>BASECLASS</parameter>.hpp</filename>)
	must be included in the head of the file.</para>
      </sect3>

      <sect3>
	<title>DM macros</title>

	<para>You may notice that it is using three special macros:
    <function>USE_LIBECS</function>, <function>
    LIBECS_DM_OBJECT</function>, and
    <function>DM_INIT</function>.</para>

	<para><function>USE_LIBECS</function> declares use of
         <productname>libecs</productname> library, which is the core
         library of &app, in this file after the line.</para>

	<para><function>LIBECS_DM_OBJECT( <parameter>TYPE</parameter>,
          <parameter>CLASSNAME</parameter> )</function> should be
          placed on the top of the class definition part (immediately
          after '{' of the class).  This macro declares that this is a
          DM class.  This macro makes it dynamically instantiable, and
          automatically defines
          <methodname>getClassName</methodname>() method.  Note that
          this macro specifies public: field inside, and thus anything
          comes after this is placed in public.  For clarity it is a
          good idea to always write public: explicitly after this
          macro.  <programlisting> LIBECS_DM_OBJECT( TYPE, CLASSNAME )
          public:</programlisting>
</para>

	<para><function>DM_INIT( <parameter>TYPE</parameter>,
	<parameter>CLASSNAME</parameter> )</function> exports the
	class <parameter>CLASSNAME</parameter> as a DM class of type
	<parameter>TYPE</parameter>.  This must come after the
	definition (not just a declaration) of the class to be
	exported with
	a <function>LIBECS_DM_OBJECT</function> call.</para>

      </sect3>

      <sect3>
	<title>Constructor and destructor</title> 

	<para>DM objects are always instantiated by calling the
	constructor with no argument.  The destructor is defined virtual
        in the base class.</para>
      </sect3>

      <sect3>
	<title>Other C++ code</title>

	<para>The only limitation is the <function>DM_INIT</function>
	macro, which exports a class as a DM class, can appear only
	once in a compilation unit which forms a single shared library
	file.</para>

	<para>Except for that, there is no limitation as far as the C++
	compiler understands it.  There can be any C++ statements
	inside and outside of the class definition including; other
	class definitions, nested classes, typedefs, static functions,
	namespaces, and even template<>.</para>

	<para>Be careful, however, about namespace corruptions. You
          may want to use private C++ namespaces and static functiont
          when a class or a function declared outside the DM class is
          needed.</para>
      </sect3>


    </sect2>


    </sect1>

  <sect1>
    <title>PropertySlot</title>

    <sect2>
      <title>What is <classname>PropertySlot</classname></title>

      <para>All of the DM base classes,
         <classname>Process</classname>,
         <classname>Variable</classname>,
         <classname>System</classname> and
         <classname>Stepper</classname> are
         <classname>PropertyInterface</classname>s, which means that
         these classes can hold <classname>PropertySlot</classname>s,
         or just object <emphasis>properties</emphasis>.</para>

      <para></para>

    </sect2>

    <sect2>
      <title>How to define a <classname>PropertySlot</classname></title>
      <para></para>

      <sect3>
	<title>Declaring a <classname>PropertySlot</classname></title>
	
	<para>CREATE_PROPERTYSLOT</para>

	<para>
If <classname>PropertySlot</classname>s with the same name are created
for an object, the later one overrides the former.</para>
      </sect3>

      <sect3>
	<title>Defining set / get methods</title>

	<para></para>

      </sect3>

      <sect3>
	<title>Virtual functions and <classname>PropertySlot</classname>s</title>

	<para>Virtual functions doesn't work for
	<classname>PropertySlot</classname>.  The functions given as
	set / get methods of <classname>PropertySlot</classname>s
	work and are treated as non-virtual functions.  If you have two DM
	classes A and B, and B inherits A with a virtual function
	overridden, it's likely that you want to define
	<classname>PropertySlot</classname>s of the same name for both
	classes.</para>

	<note>
	  <para>This can be easily understood if you remember
            <classname>PropertySlot</classname>s are defined in
            constructors. In C++ objects are constructed in a
            bottom-up fashion, or from base to derived classes. Thus
            the constructors are called in the same order, and always
            the latest ones are taken.</para>
	  </note>

      </sect3>

    </sect2>

    <sect2>
      <title>Using <classname>PropertySlot</classname>s from model
      files</title> <para></para>
    </sect2>

    <sect2>
      <title>Using <classname>PropertySlot</classname>s in the
      simulation</title>

      <para></para>
    </sect2>

  </sect1>


    <sect1>
      <title>Defining a new Process class</title>


      <para>To define a new <classname>Process</classname> class, 
      at least <methodname>process()</methodname> and 
      <methodname>initialize()</methodname> methods must be defined.
      </para>


      <para>VariableReference, VariableReferenceVector, FluxProcess</para>

    <example>
      <title>SimpleFluxProcess.cpp</title>
    <programlisting linenumbering="numbered">
#include "libecs.hpp"
#include "FluxProcess.hpp"
#include "PropertySlotMaker.hpp"

USE_LIBECS;

class SimpleFluxProcess
  :
  public FluxProcess
{

  LIBECS_DM_OBJECT( Process, SimpleFluxProcess );

 public:

  SimpleFluxProcess()
    {
      CREATE_PROPERTYSLOT_SET_GET( Real, k, SimpleFluxProcess );
    }

  SIMPLE_SET_GET_METHOD( Real, k );

  virtual void initialize()
    {
      FluxProcess::initialize();
      S0 = getVariableReference( "S0" );
    }

  virtual void process()
    {
      setFlux( k * S0.getConcentration() );
    }

 protected:

  Real k;
  VariableReference S0;
};

DM_INIT( Process, SimpleFluxProcess );
</programlisting>
    </example>

      
    </sect1>

    <sect1>
      <title>Defining a new Stepper class</title>
    <para></para>
    </sect1>


    <sect1>
      <title>Defining a new Variable class</title>
    <para></para>
    </sect1>

    <sect1>
      <title>Defining a new System class</title>
    <para></para>
    </sect1>

  </chapter>



<!--
Local Variables:
mode: sgml
sgml-parent-document: ("ecell3-users-manual.xml" "book" "chapter")
End:
-->
